---
title: "Human ventromedial prefrontal cortex is necessary for prosocial motivation"
author: "Patricia Lockwood & Jo Cutler"
date: '2023'
output: 
  html_document:
    keep_md: true
fig_width: 8
---

# Analysis

```{css, echo=FALSE}
img {
max-width:150%;
height: auto;
}
```

## Set up and functions

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)
options(digits = 3)

# load required packages and functions

require(pacman)
pacman::p_load(BayesFactor, # for BF
  # buildmer, # optimise mixed models
  boot, # bootstrapping
  # coefplot, # for plotting model coefficients
  # coin, # used by other packages
  cowplot, # arrange plots
  # effects,
  emmeans, # post-hoc contrasts
  english, # numbers as words
  ggpubr, # extra plot functions
  ggsignif, # significance stars
  ggtext, # formatting text
  # grid, # plot dimensions
  # gridExtra,
  # insight, # for performance to work
  kableExtra, # table formatting
  lme4, # mixed models
  lmerTest,
  # MASS,
  # magick, # image manipulation
  parameters, # format and standardise
  # performance, # check model assumptions
  # ppcor,
  # plyr, #
  # psych, # for statistical tests
  # robustlmm, 
  rstatix, # for Wilcoxon effect sizes
  # sjstats,
  tidyverse)#, # ggplot, dplyr packages
# tidyselect)

# pacman::p_load(car, DataExplorer, broom, pander, scales, Hmisc, fitdistrplus, tidyr, stringi, robust)

### Function to format p values taken from https://stackoverflow.com/questions/23018256/printing-p-values-with-0-001

## version without = sign
pvalr <- function(pvals, sig.limit = .001, digits = 3, html = FALSE) {
  
  roundr <- function(x, digits = 1) {
    res <- sprintf(paste0('%.', digits, 'f'), x)
    zzz <- paste0('0.', paste(rep('0', digits), collapse = ''))
    res[res == paste0('-', zzz)] <- zzz
    res
  }
  
  sapply(pvals, function(x, sig.limit) {
    if (x < sig.limit)
      if (html)
        return(sprintf('&lt; %s', format(sig.limit))) else
          return(sprintf('<%s', format(sig.limit)))
    if (x > .1)
      return(roundr(x, digits = 2)) else
        return(roundr(x, digits = digits))
  }, sig.limit = sig.limit)
}

## version with sign

pvalrf <- function(pvals, sig.limit = .001, digits = 3, html = FALSE) {
  
  roundr <- function(x, digits = 1) {
    res <- sprintf(paste0('%.', digits, 'f'), x)
    zzz <- paste0('0.', paste(rep('0', digits), collapse = ''))
    res[res == paste0('-', zzz)] <- zzz
    res
  }
  
  sapply(pvals, function(x, sig.limit) {
    if (x < sig.limit){
      if (html) {return(sprintf('&lt; %s', format(sig.limit)))
      } else {return(sprintf('<%s', format(sig.limit)))}
    }
    if (x > .1){
      if (html) {return(sprintf('&equals;%s', format(roundr(x, digits = 2)))) 
      } else {return(sprintf('=%s', format(roundr(x, digits = 2))))}
    } else {
      if (html) {return(sprintf('&equals;%s', format(roundr(x, digits = digits))))
      } else {return(sprintf('=%s', format(roundr(x, digits = digits))))}
    }
  }, sig.limit = sig.limit)
}

```

```{r settings, warning=FALSE, message=FALSE, echo=FALSE}

## general settings

# 1 to save, 0 to not save
saveplots <- 0
path <- 'plots'
savecsvs <- 0

# settings used throughout script to make figures the same height and text size
resolution <- 300
plotH <- 4
plotW <- 2.5
corrplotW <- plotH*2
modplotW <- plotH*1.55
axtext <- 16
axtitle <- axtext + 2

lims <- c(0, NA)

hc.self.x <- 1
hc.other.x <- 2
vmpfc.self.x <- 3
vmpfc.other.x <- 4
lc.self.x <- 5
lc.other.x <- 6
hc.x <- 1.5
vmpfc.x <- 3.5
lc.x <- 5.5

klabel <- '*\u039A* parameter'
blabel <- '*\u03B2* parameter'
models <- c('1<i>\u039A</i>1<i>\u03B2</i> p', '1<i>\u039A</i>1<i>\u03B2</i> l', '1<i>\u039A</i>1<i>\u03B2</i> h',
            '1<i>\u039A</i>2<i>\u03B2</i> p', '1<i>\u039A</i>2<i>\u03B2</i> l', '1<i>\u039A</i>2<i>\u03B2</i> h',
            '2<i>\u039A</i>1<i>\u03B2</i> p', '2<i>\u039A</i>1<i>\u03B2</i> l', '2<i>\u039A</i>1<i>\u03B2</i> h',
            '2<i>\u039A</i>2<i>\u03B2</i> p', '2<i>\u039A</i>2<i>\u03B2</i> l', '2<i>\u039A</i>2<i>\u03B2</i> h')

alphas <- rep(c(1, 1),3)
sizes <- rep(c(0.4, 0.4),3)

agent.lims <- c('self', 'other')
agent.labs <- c('Self', 'Other')
agent.fills <- c('#D85F59', '#7D9DD6')
agent.colours <- c('#ECB1AE', '#BECEEA')  

group.lims <- c('HC', 'vmPFC', 'LC')
group.labs <- c('Healthy\ncontrols', 'vmPFC\nlesions', 'Lesion\ncontrols')
group.fills <- c('#B76333', '#4C0038', '#8D9365')
group.colours <- c('#B76333', '#4C0038', '#8D9365')
group.labs.leg <- sub('\n', ' ', group.labs) # replace new lines with spaces for labels in legend instead of x axis
group.labs.leg.lab <- group.labs
names(group.labs.leg.lab) <- group.lims

group.lims.ol <- c('vmPFC', 'LC', 'OL')
group.labs.ol <- c('vmPFC\nlesions', 'Lesion\ncontrols', 'Other\nlesions')
group.labs.leg.ol <- sub('\n', ' ', group.labs.ol)
group.fills.ol <- c('#4C0038', '#8D9365', 'grey')

inter.lims <- c("HC:self","HC:other","vmPFC:self","vmPFC:other","LC:self", "LC:other")
inter.labs <- c('Healthy controls self', 'Healthy controls other', 'vmPFC lesions self', 'vmPFC lesions other', 'Lesion controls self', 'Lesion controls other')
inter.lims2 <- c("self:HC","other:HC","self:vmPFC","other:vmPFC","self:LC", "other:LC")
inter.labs2 <- c('', 'Healthy\ncontrols', '', 'vmPFC\nlesions', '', 'Lesion\ncontrols')

effort.labs <- c("Effort 2", "Effort 3", "Effort 4", "Effort 5", "Effort 6")
names(effort.labs) <- c("2", "3", "4", "5", "6")

reward.labs <- c("Reward 2", "Reward 3", "Reward 4", "Reward 5", "Reward 6")
names(reward.labs) <- c("2", "3", "4", "5", "6")

sig.order <- c("hc","vmpfc","lc", "so c-m", "so m-l", "so c-l")

theme.paper = theme(panel.background = element_rect(fill='transparent'),
                    axis.line = element_line(color='black'),
                    panel.grid.minor = element_line(color='transparent'),
                    axis.title.x = element_text(size=axtitle, vjust=-.25, face = "bold"),
                    axis.title.y = element_text(size=axtitle, vjust=1, face = "bold"),
                    axis.text.x = element_text(size=axtext, colour="black", vjust=.7),
                    axis.text.y = element_text(size=axtext, colour="black"),
                    legend.text = element_text(size=axtext),
                    legend.title = element_text(size=axtext, face="bold"),
                    strip.text.y = element_text(size = axtext),
                    strip.text.x = element_text(size = axtext), 
                    plot.margin = margin(10,10,10,10))

```

```{r data-prep, warning=FALSE, message=FALSE, echo=FALSE}

### Load & tidy data

# Long trial-by-trial data containing data from healthy controls (HC), vmPFC lesion (vmPFC), lesion control (LC), and other lesion (OL) patients
df.full = read_csv(
  "data/lme_data_PM_am-mpfc-lc-ol.csv",
  col_names = T, show_col_types = FALSE)

df.full$Success[df.full$Choice != 1] <- NA

# Tidy the data, create factor versions of effort and reward ('.f'), square effort but keep raw scores too ('.r')
df.full <- df.full                                %>%  
  dplyr::filter(Choice < 2)                       %>% # removes missing data
  mutate(ID = factor(ID))                         %>% # recodes as factor
  mutate(PM_ID = factor(PM_ID))                   %>% # recodes as factor
  mutate(Choice.r = Choice)                       %>% # create numerical index of 1 and 0 for choices
  mutate(Choice = factor(Choice))                 %>% # recodes as factor
  mutate(Reward.f = factor(Reward))               %>% # new variable as factor 
  mutate(Effort.f = factor(Effort))               %>% # new variable as factor
  mutate(Effort.r = Effort)                       %>% # copies raw scores to new variable
  mutate(Effort.raw = Effort)                     %>% # copies raw scores to new variable
  mutate(Reward.r = Reward)                       %>% # copies raw scores to new variable
  mutate(Effort = Effort^2)                       %>% # squares
  mutate(Recipient = factor(Agent,
                            levels =c(1,2),
                            labels = c("self", "other"),
                            ordered=F))                                       %>% # factorise agent with labels
  mutate(Recipient_s2z = Recipient)                                       %>% # copy of agent factor to change contrasts below
  mutate(Group_vmpfc = factor(Group, 
                              levels = c(2,1,3,4), 
                              labels = c("vmPFC", "HC", "LC", "OL"),
                              ordered=F))                                  %>% # factor with vmpfc lesions as the reference group
  mutate(Group = factor(Group, 
                        levels =c(1,2,3,4),
                        labels = c("HC", "vmPFC", "LC", "OL"),
                        ordered=F))                                       %>% # factor with healthy controls as the reference group
  mutate(Success.r = Success)                                             %>% # create numerical index of 1 and 0 for success
  mutate(Success = factor(Success))                                           # recodes as factor

contrasts(df.full$Recipient_s2z) <- contr.sum(length(levels(df.full$Recipient))) 

# Create a version of this data (prefix pfe) with all patients included in the Fixed Effects analysis to use below to extract parameters for lesion mapping (vmPFC, LC and OL)
# For extracting parameters from random effects for all lesion patients, zscore across lesion patients
pfe.df <-   
  df.full                                                     %>%
  # subset(Group != "HC")                                       %>% # removes healthy controls
  mutate(Reward = scale(Reward))                              %>% # zscores
  mutate(Effort.r = scale(Effort.r))                          %>% # zscores raw score
  mutate(Effort = scale(Effort))                              %>% # zscores squared score
  mutate(Group = droplevels(Group)) %>% 
  mutate(Group_vmpfc = droplevels(Group_vmpfc))

# For models comparing controls, vmPFC and LC, zscore reward and (squared) effort across all participants in the dataset
df <- 
  df.full                                                     %>% 
  subset(Group != "OL")                                       %>% # removes other lesion group
  mutate(Reward = scale(Reward))                              %>% # zscores
  mutate(Effort.r = scale(Effort.r))                          %>% # zscores raw score
  mutate(Effort = scale(Effort))                              %>% # zscores squared score
  mutate(Group = droplevels(Group)) %>% 
  mutate(Group_vmpfc = droplevels(Group_vmpfc))

# Data with model parameters, questionnaires and demographics
df.2k.full <- read_csv("data/PM_vmpfc_combined_data_totals.csv", col_names = T, show_col_types = FALSE, na = c("NaN", "n/a"))

df.2k.full <- df.2k.full                          %>% 
  drop_na(ID_Code)                                %>% # ensure no extra empty rows
  mutate(ID = factor(ID_Code))                    %>% # factorise ID and rename
  mutate(Group_vmpfc = factor(Group, 
                              levels = c(2,1,3,4), 
                              labels = c("vmPFC", "HC", "LC", "OL"),
                              ordered=F))                                  %>% # factor with vmpfc lesions as the reference group
  mutate(Group = factor(Group, 
                        levels =c(1,2,3,4),
                        labels = c("HC", "vmPFC", "LC", "OL"),
                        ordered=F))                                       %>% # factor with healthy controls as the reference group
  mutate(Gender = factor(Gender, 
                         levels = c("1", "2"), 
                         labels = c("male", "female")))

contrasts(df.2k.full$Gender) <- contr.sum(length(levels(df.2k.full$Gender))) 

df.2k <- df.2k.full %>% 
  subset(Group != "OL") %>% # removes other lesion group
  mutate(Group = droplevels(Group)) %>% 
  mutate(Group_vmpfc = droplevels(Group_vmpfc))

df.2kl.full <- df.2k.full %>% 
  plyr::rename(c("PM_self_k"="agent1-k", 
                 "PM_other_k"="agent2-k", 
                 "PM_self_beta"="agent1-beta", 
                 "PM_other_beta"="agent2-beta", 
                 "PM_self_choice"="agent1-prop_accept", 
                 "PM_other_choice"="agent2-prop_accept", 
                 "PM_self_RT"="agent1-RT", 
                 "PM_other_RT"="agent2-RT"))                                             %>%
  tidyr::pivot_longer(
    starts_with("agent"),
    names_to = c("Recipient", ".value"),
    names_sep = "-")                                %>% 
  mutate(Recipient = factor(Recipient,
                            levels = c("agent1", "agent2"),
                            labels = c("self", "other"),
                            ordered=F))                                       %>% # factorise agent with labels
  mutate(Recipient_s2z = Recipient)                                               %>% # copy of agent factor to change contrasts below
  mutate(Condition = interaction(Recipient, Group, sep = ":"))

contrasts(df.2kl.full$Recipient_s2z) <- contr.sum(length(levels(df.2kl.full$Recipient)))

df.2kl <- df.2kl.full %>% 
  subset(Group != "OL") %>% # removes other lesion group
  mutate(Group = droplevels(Group)) %>% 
  mutate(Group_vmpfc = droplevels(Group_vmpfc))

```

```{r demographics, echo = FALSE, cache = TRUE, warning=FALSE, message=FALSE}

# Demographics

demographics.ol <- df.2k.full %>%
  dplyr::select(contains("Group", ignore.case = F), matches("Age", ignore.case = F), matches("Gender", ignore.case = F), matches(c("Qualification", "AMI_tot")), contains(c("BDI_total", "seconds"))) %>% 
  mutate(Gender = as.numeric(Gender == "male"))

demographics.ol <- demographics.ol %>%   
  mutate(Trail_A = demographics.ol$`Trail_Making_A_(seconds)'`) %>% 
  mutate(Trail_B = demographics.ol$`Trail_Making_B_(seconds)'`) %>% 
  select(!contains("seconds"))

demographics <- demographics.ol %>%
  subset(Group != "OL") 

demographics2grp <- demographics %>% subset(Group == "HC" | Group == "vmPFC") %>% droplevels("Group") %>% select(!c("Group"))

w_stat_hc_vmPFC <- apply(subset(demographics2grp, select=-Group_vmpfc), 2, function(y) wilcox.test(y ~ demographics2grp$Group_vmpfc, exact = FALSE)$statistic)
w_pval_hc_vmPFC <- apply(subset(demographics2grp, select=-Group_vmpfc), 2, function(y) wilcox.test(y ~ demographics2grp$Group_vmpfc, exact = FALSE)$p.value)

demographics2grp <- demographics %>% subset(Group == "LC" | Group == "vmPFC") %>% droplevels("Group") %>% select(!c("Group"))

w_stat_lc_vmPFC <- apply(subset(demographics2grp, select=-Group_vmpfc), 2, function(y) wilcox.test(y ~ demographics2grp$Group_vmpfc, exact = FALSE)$statistic)
w_pval_lc_vmPFC <- apply(subset(demographics2grp, select=-Group_vmpfc), 2, function(y) wilcox.test(y ~ demographics2grp$Group_vmpfc, exact = FALSE)$p.value)

demographics2grp <- demographics %>% subset(Group == "HC" | Group == "LC") %>% droplevels("Group") %>% select(!c("Group"))

w_stat_hc_lc <- apply(subset(demographics2grp, select=-Group_vmpfc), 2, function(y) wilcox.test(y ~ demographics2grp$Group_vmpfc, exact = FALSE)$statistic)
w_pval_hc_lc <- apply(subset(demographics2grp, select=-Group_vmpfc), 2, function(y) wilcox.test(y ~ demographics2grp$Group_vmpfc, exact = FALSE)$p.value)

demographics.ol <- demographics.ol %>%
  dplyr::group_by(Group) %>% 
  droplevels()

d.mean <- demographics.ol %>%
  dplyr::summarise_if(is.numeric, list(mean = mean), na.rm = T) 
d.min <- demographics.ol %>%
  dplyr::summarise_if(is.numeric, list(min = min), na.rm = T)
d.max <- demographics.ol %>%
  dplyr::summarise_if(is.numeric, list(max = max), na.rm = T)
d.sd <- demographics.ol %>%
  dplyr::summarise_if(is.numeric, list(sd = sd), na.rm = T)
d.n <- demographics.ol %>%
  dplyr::summarise(n = n())
d.gender <- as.data.frame.matrix(table(demographics.ol$Group, demographics.ol$Gender))

dem <- bind_cols(d.mean[2:ncol(d.mean)], d.min[2:ncol(d.min)], d.max[2:ncol(d.max)], d.sd[2:ncol(d.sd)], d.n[2], d.gender)

diff.gender <- chisq.test(d.gender)

diff.gender.HC.vmPFC <- chisq.test(d.gender[1:2,])
diff.gender.LC.vmPFC <- chisq.test(d.gender[2:3,])
diff.gender.HC.LC <- chisq.test(d.gender[c(1,3),])

d.means <- data.frame(t(d.mean[-1]))
colnames(d.means) <- d.mean$Group
rownames(d.means) <- str_remove(rownames(d.means), "_mean")

d.sds <- data.frame(t(d.sd[-1]))
colnames(d.sds) <- d.sd$Group
rownames(d.sds) <- str_remove(rownames(d.sds), "_sd")

d.means <- data.frame(d.means$HC,
                      d.sds$HC,
                      d.means$vmPFC,
                      d.sds$vmPFC,
                      d.means$LC,
                      d.sds$LC,
                      # t_pval_hc_vmPFC, t_pval_lc_vmPFC, t_pval_hc_lc) %>%
                      w_pval_hc_vmPFC, w_pval_lc_vmPFC, w_pval_hc_lc) %>% 
  add_column(measure = rownames(d.means), .before = "d.means.HC") %>% 
  remove_rownames()

```

## Analyse credits earned

### Models of credits

```{r credit-models, warning=FALSE, message=FALSE, echo=FALSE}

credits <-
  df                %>%
  dplyr::group_by(PM_ID, Group, Recipient)        %>%
  dplyr::summarise(total_credits = sum(Outcome), .groups = "drop") %>% 
  mutate(Condition = interaction(Group, Recipient, sep = ":")) %>% 
  mutate(Condition = factor(Condition)) %>% 
  mutate(Condition2 = interaction(Recipient, Group, sep = ":")) %>% 
  mutate(Condition2 = factor(Condition2)) %>% 
  mutate(ID_Code = as.numeric(as.character(PM_ID)))

df.2kl <- left_join(df.2kl, credits %>% select(c("ID_Code", "total_credits", "Recipient")), by = c("ID_Code", "Recipient"))

contrasts(df.full$Recipient_s2z) <- contr.sum(length(levels(df.full$Recipient))) 

# ### Use generalised linear mixed-effects model to analyse the data with family & link function to account for skew

m.gam.log <- glmer(total_credits ~ Recipient_s2z*Group_vmpfc + (1|ID), data = df.2kl, family = Gamma(link = 'log'), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))

m.credits.best <- m.gam.log

r.credits.full <- model_parameters(m.credits.best, exponentiate = T)
r.credits <- r.credits.full %>%
  dplyr::filter(Effects == "fixed") %>%
  select(!c(df_error, Effects, Group, CI)) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Recipient_s2z1", replacement = "Recipient (Self vs. Other)")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Group_vmpfcHC", replacement = "Group (vmPFC vs. HC)")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Group_vmpfcLC", replacement = "Group (vmPFC vs. LC)")) %>%
  mutate(Parameter = str_replace_all(Parameter, pattern = ":", replacement = " * "))

credits.con.ag <- contrast(emmeans(m.credits.best, ~ Recipient_s2z | Group_vmpfc), 'pairwise', by=NULL, adjust = "none", type = "response")
credits.con.ag <- as.data.frame(credits.con.ag)

credits.con.ag1 <- credits.con.ag %>% 
  subset(contrast == "self vmPFC / self HC" | contrast == "self vmPFC / self LC" | contrast == "self HC / self LC") %>% 
  add_column(term = "Effect of group for self", .before = "contrast")

credits.con.ag2 <- credits.con.ag %>% 
  subset(contrast == "other vmPFC / other HC" | contrast == "other vmPFC / other LC" | contrast == "other HC / other LC") %>% 
  add_column(term = "Effect of group for other", .before = "contrast")

credits.con.ag3 <- credits.con.ag %>% 
  subset(contrast == "self vmPFC / other vmPFC" | contrast == "self HC / other HC" | contrast == "self LC / other LC") %>% 
  add_column(term = "Effect of recipient in each group", .before = "contrast")

credits.con.inter <- contrast(contrast(emmeans(m.credits.best, ~ Recipient_s2z | Group_vmpfc), 'pairwise'), 'pairwise', by=NULL, adjust = "none", type = "response")
credits.con.inter <- as.data.frame(credits.con.inter) %>% 
  add_column(term = "Recipient*group interaction", .before = "contrast")

credits.con.all <- bind_rows(credits.con.ag1, credits.con.ag2, credits.con.ag3, credits.con.inter) %>% 
  select(!c(df))

```

### Post-hoc tests on credits

```{r credit-sig, echo = FALSE, cache = TRUE, warning=FALSE}

credit.sig <- array(NA,c(5,length(sig.order)))
i <- 1

# comparing recipients for each group
if (credits.con.ag$p.value[credits.con.ag$contrast == "self HC / other HC"] < .05) { credit.sig[1,1] <- "*" 
} else if (credits.con.ag$p.value[credits.con.ag$contrast == "self HC / other HC"] >= .05) {credit.sig[1,1] <- NA }
i <- i + 1
if (credits.con.ag$p.value[credits.con.ag$contrast == "self vmPFC / other vmPFC"] < .05) { credit.sig[1,2] <- "*" 
} else if (credits.con.ag$p.value[credits.con.ag$contrast == "self vmPFC / other vmPFC"] >= .05) {credit.sig[1,2] <- NA } 
i <- i + 1
if (credits.con.ag$p.value[credits.con.ag$contrast == "self LC / other LC"] < .05) { credit.sig[1,3] <- "*" 
} else if (credits.con.ag$p.value[credits.con.ag$contrast == "self LC / other LC"] >= .05) {credit.sig[1,3] <- NA }
i <- i + 1

# # comparing self - other difference between groups
if (credits.con.inter$p.value[credits.con.inter$contrast == "(self / other vmPFC) / (self / other HC)"] < .05) { credit.sig[1,i] <- "*"
} else if (credits.con.inter$p.value[credits.con.inter$contrast == "(self / other vmPFC) / (self / other HC)"] >= .05) { credit.sig[1,i] <- NA }
i <- i + 1
if (credits.con.inter$p.value[credits.con.inter$contrast == "(self / other vmPFC) / (self / other LC)"] < .05) { credit.sig[1,5] <- "*"
} else if (credits.con.inter$p.value[credits.con.inter$contrast == "(self / other vmPFC) / (self / other LC)"] >= .05) { credit.sig[1,i] <- NA }
i <- i + 1
if (credits.con.inter$p.value[credits.con.inter$contrast == "(self / other HC) / (self / other LC)"] < 0.05) { credit.sig[1,i] <- "*"
} else if (credits.con.inter$p.value[credits.con.inter$contrast == "(self / other HC) / (self / other LC)"] >= .05) { credit.sig[1,i] <- NA }
i <- i + 1

colnames(credit.sig) <- sig.order

```

### Bayesian tests on credits

```{r credits-bf, echo = FALSE, cache = TRUE, warning=FALSE}

credits.bf10.hc.vmpfc.self <- ttestBF(credits$total_credits[credits$Condition == "HC:self"], 
                                      credits$total_credits[credits$Condition == "vmPFC:self"])
credits.bf01.hc.vmpfc.self <- 1 / credits.bf10.hc.vmpfc.self
credits.bf01.hc.vmpfc.self <- extractBF(credits.bf01.hc.vmpfc.self)

credits.bf10.hc.vmpfc.other <- ttestBF(credits$total_credits[credits$Condition == "HC:other"], 
                                       credits$total_credits[credits$Condition == "vmPFC:other"])
credits.bf01.hc.vmpfc.other <- 1 / credits.bf10.hc.vmpfc.other
credits.bf01.hc.vmpfc.other <- extractBF(credits.bf01.hc.vmpfc.other)

credits.bf10.lc.vmpfc.self <- ttestBF(credits$total_credits[credits$Condition == "LC:self"], 
                                      credits$total_credits[credits$Condition == "vmPFC:self"])
credits.bf01.lc.vmpfc.self <- 1 / credits.bf10.lc.vmpfc.self
credits.bf01.lc.vmpfc.self <- extractBF(credits.bf01.lc.vmpfc.self)

credits.bf10.lc.vmpfc.other <- ttestBF(credits$total_credits[credits$Condition == "LC:other"], 
                                       credits$total_credits[credits$Condition == "vmPFC:other"])
credits.bf01.lc.vmpfc.other <- 1 / credits.bf10.lc.vmpfc.other
credits.bf01.lc.vmpfc.other <- extractBF(credits.bf01.lc.vmpfc.other)

credits.bf10.hc.lc.self <- ttestBF(credits$total_credits[credits$Condition == "HC:self"], 
                                   credits$total_credits[credits$Condition == "LC:self"])
credits.bf01.hc.lc.self <- 1 / credits.bf10.hc.lc.self
credits.bf01.hc.lc.self <- extractBF(credits.bf01.hc.lc.self)

credits.bf10.hc.lc.other <- ttestBF(credits$total_credits[credits$Condition == "HC:other"], 
                                    credits$total_credits[credits$Condition == "LC:other"])
credits.bf01.hc.lc.other <- 1 / credits.bf10.hc.lc.other
credits.bf01.hc.lc.other <- extractBF(credits.bf01.hc.lc.other)

```

### Plot credits

```{r credits-plot, warning=FALSE, message=FALSE, echo = FALSE, fig.height=6, fig.width=6}

### Group * agent interaction

credit.sig[2,] <- c(430,430,430,490,520,520) 
credit.sig[3,] <- c(hc.self.x, vmpfc.self.x, lc.self.x, hc.x, vmpfc.x, hc.x)
credit.sig[4,] <- c(hc.other.x, vmpfc.other.x, lc.other.x, vmpfc.x, lc.x, lc.x)
credit.sig[5,] <- c(0, 0, 0, 0.02, 0.02, 0.02)

graphname <- paste0(path,'/Total_credits_earned.tiff')  

if (saveplots == 1) {tiff(graphname, units="in", width = plotW*2, height = plotH, res = resolution)}

pd <- position_jitter(height = 0, width = 0.2, seed = 123)

credit.plt <- ggplot(credits, aes(x=Condition2, y=total_credits, fill = Recipient, color = Recipient, alpha = Condition, size = Condition)) +
  stat_summary(fun = mean, geom = "bar", position=position_dodge(0.75), width = 0.75, alpha = 1, color = 'black') +
  geom_line(aes(group = PM_ID), position = pd, colour = "grey", alpha = 0.5) +
  geom_point(aes(group = PM_ID), position = pd, size = 3, alpha = 0.5, show.legend = FALSE) +
  stat_summary(fun = mean, geom = "bar", position=position_dodge(0.75), width = 0.75, alpha = 0, color = 'black') +
  stat_summary(fun.data = "mean_cl_boot", geom = "errorbar", conf.int=.95, position=position_dodge(0.75), width = 0, color = 'black', alpha = 1) +
  scale_x_discrete(name = '', limits = inter.lims2, labels = inter.labs2) +
  scale_y_continuous(name = "Credits earned", limits = lims, expan = expansion(mult = c(0, 0.1))) + #, breaks = c(0.25,0.5,0.75,1)) +
  scale_size_manual(limits = inter.lims, values = sizes, guide = 'none') +
  scale_alpha_manual(limits = inter.lims, values = alphas, guide = 'none') +
  scale_fill_manual(limits = agent.lims, values = agent.fills, labels = agent.labs) +
  scale_color_manual(limits = agent.lims, values = agent.colours, labels = agent.labs) +
  theme_classic() +
  theme(legend.position = 'bottom',
        legend.margin=margin(0,0,0,0),
        legend.box.margin=margin(0,0,0,0),
        legend.box.spacing = unit(0, "pt"),
        legend.title = element_blank(),
        axis.text=element_text(size = axtext), 
        axis.text.x=element_text(size = axtext, hjust = 1),
        axis.title.y=element_markdown(size = axtitle),
        legend.text=element_text(size = axtitle))


  for (c in 1:ncol(credit.sig)){
    credit.plt <- credit.plt + geom_signif(annotation = credit.sig[1,c], y_position = as.numeric(credit.sig[2,c]),
                                           xmin = as.numeric(credit.sig[3,c]), xmax = as.numeric(credit.sig[4,c]),
                                           tip_length = as.numeric(credit.sig[5,c]), colour = 'black', textsize = 7)}

# print(credit.plt)

credit.lab <- ggplot() +
  geom_textbox(mapping = aes(0.85, 0.25,
                             label = "<span style='font-size:14pt'>← <i>Smaller bonus</i><span>", text.color = "black", orientation = "left-rotated",
                             box.color = "transparent", hjust = 0, vjust = 0.5, halign = 0), width = unit(0.47, "npc")) +
  geom_textbox(mapping = aes(0.85, 0.85,
                             label = "<span style='font-size:14pt'><i>Larger bonus</i> →<span>", text.color = "black", orientation = "left-rotated",
                             box.color = "transparent", hjust = 0.9, vjust = 0.5, halign = 1), width = unit(0.47, "npc")) +
  xlim(0, 1) +
  theme_classic() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.x = element_blank(),
        axis.line.x = element_blank(),
        axis.title.y = element_blank(),
        axis.line.y = element_blank())

credit.lab <- plot_grid(credit.lab, NA, nrow = 2, rel_heights = c(1,0.1))

credit.plt <- plot_grid(credit.lab, credit.plt, ncol = 2, rel_widths = c(0.15,1))

if (saveplots == 1) {
  credit.plt
  dev.off()}

```

## Analyse choice data

```{r choice-models, eval=FALSE, echo=FALSE}

### Automate comparing GLMMs of choice data

# Define the model with all interactions - eval=FALSE because they are loaded below

# full model with effort continuous + squared & reward continuous

m.choice.build <- buildmer(Choice ~ Effort*Reward*Recipient_s2z*Group_vmpfc +
                                       (1 + Effort*Reward*Recipient_s2z | ID),
                                     data = df, family = 'binomial',
                                     buildmerControl=list(crit='LRT', 
                                                          args=list(control=lmerControl(optimizer='bobyqa', optCtrl=list(maxfun=2e5)))))
save(m.choice.build, file = "output/model_choice_build.RData")

```

```{r choice-models-bayes, eval=FALSE, echo=FALSE}

m.choice.best.glmer <- glmer(Choice ~ Effort + Reward + Recipient_s2z + Group_vmpfc + Effort:Group_vmpfc + Reward:Recipient_s2z + Recipient_s2z:Group_vmpfc + Effort:Reward + (1 + Reward + Recipient_s2z + Effort + Reward:Recipient_s2z + Effort:Reward | ID), data = df, family = 'binomial', control = glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

m.choice.best.glmer.RGinter <- glmer(Choice ~ Effort + Reward + Recipient_s2z + Group_vmpfc + Effort:Group_vmpfc + Reward:Recipient_s2z + Recipient_s2z:Group_vmpfc + Effort:Reward  + Group_vmpfc:Reward + (1 + Reward + Recipient_s2z + Effort + Reward:Recipient_s2z + Effort:Reward | ID), data = df, family = 'binomial', control = glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

save(m.choice.best.glmer, m.choice.best.glmer.RGinter, file = "output/model_choice_RG_inter.RData")

m.choice.best.glmer.self <- glmer(Choice ~ Effort + Reward + Group_vmpfc + Effort:Group_vmpfc + Effort:Reward + (1 + Reward + Effort + Effort:Reward | ID), data = subset(df, Recipient_s2z == "self"), family = 'binomial', control = glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

m.choice.best.glmer.other <- glmer(Choice ~ Effort + Reward + Group_vmpfc + Effort:Group_vmpfc + Effort:Reward + (1 + Reward + Effort + Effort:Reward | ID), data = subset(df, Recipient_s2z == "other"), family = 'binomial', control = glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

save(m.choice.best.glmer.self, m.choice.best.glmer.other, file = "output/model_choice_EG_by_R.RData")

```

### Format results

```{r choice-models-load, warning=FALSE, message=FALSE, echo=FALSE}

# Load models saved above

load("output/model_choice_EG_by_R.RData")
load("output/model_choice_build.RData")
load("output/model_choice_RG_inter.RData")

bf10.RGinter = exp((BIC(m.choice.best.glmer) - BIC(m.choice.best.glmer.RGinter))/2)
bf01.RGinter = 1 / bf10.RGinter
anova.RGinter = anova(m.choice.best.glmer, m.choice.best.glmer.RGinter) %>% 
  rename("P" = "Pr(>Chisq)")


```

```{r choice-models-format, echo = FALSE, cache = TRUE, warning=FALSE, message=FALSE}

m.choice.best <- m.choice.build@model

r.choice.a <- anova(m.choice.best) # get chisq stats, dfs and bootstrapped p values

# format and combine results

r.choice.full <- model_parameters(m.choice.best, exponentiate = T) 
r.choice <- r.choice.full %>%
  dplyr::filter(Effects == "fixed") %>%
  select(!c(df_error, Effects, Group, CI)) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Recipient_s2z1", replacement = "Recipient (Self vs. Other)")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Group_vmpfcHC", replacement = "Group (vmPFC vs. HC)")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Group_vmpfcLC", replacement = "Group (vmPFC vs. LC)")) %>%
  mutate(Parameter = str_replace_all(Parameter, pattern = ":", replacement = " * "))

r.choice.full.self <- model_parameters(m.choice.best.glmer.self, exponentiate = T) 
r.choice.self <- r.choice.full.self %>%
  dplyr::filter(Effects == "fixed") %>%
  select(!c(df_error, Effects, Group, CI)) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Recipient_s2z1", replacement = "Recipient (Self vs. Other)")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Group_vmpfcHC", replacement = "Group (vmPFC vs. HC)")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Group_vmpfcLC", replacement = "Group (vmPFC vs. LC)")) %>%
  mutate(Parameter = str_replace_all(Parameter, pattern = ":", replacement = " * "))

r.choice.full.other <- model_parameters(m.choice.best.glmer.other, exponentiate = T)
r.choice.other <- r.choice.full.other %>%
  dplyr::filter(Effects == "fixed") %>%
  select(!c(df_error, Effects, Group, CI)) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Recipient_s2z1", replacement = "Recipient (Self vs. Other)")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Group_vmpfcHC", replacement = "Group (vmPFC vs. HC)")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Group_vmpfcLC", replacement = "Group (vmPFC vs. LC)")) %>%
  mutate(Parameter = str_replace_all(Parameter, pattern = ":", replacement = " * "))

```

### Post-hoc tests on choice data

```{r choice-posthocs, echo = FALSE, cache = TRUE, warning=FALSE, message=FALSE}

choice.con.ag <- contrast(emmeans(m.choice.best, ~ Recipient_s2z | Group_vmpfc), 'pairwise', by=NULL, adjust = "none", type = "response")
choice.con.ag <- as.data.frame(choice.con.ag)

choice.con.ag1 <- choice.con.ag %>% 
  subset(contrast == "self vmPFC / self HC" | contrast == "self vmPFC / self LC" | contrast == "self HC / self LC") %>% 
  add_column(term = "Effect of group for self", .before = "contrast")

choice.con.ag2 <- choice.con.ag %>% 
  subset(contrast == "other vmPFC / other HC" | contrast == "other vmPFC / other LC" | contrast == "other HC / other LC") %>% 
  add_column(term = "Effect of group for other", .before = "contrast")

choice.con.ag3 <- choice.con.ag %>% 
  subset(contrast == "self vmPFC / other vmPFC" | contrast == "self HC / other HC" | contrast == "self LC / other LC") %>% 
  add_column(term = "Effect of recipient in each group", .before = "contrast")

choice.con.inter.eg <- emtrends(m.choice.best, pairwise ~ Group_vmpfc, var = "Effort", adjust = "none", type = "response")

choice.con.eg <- as.data.frame(choice.con.inter.eg[["emtrends"]]) %>% 
  add_column(term = "Effect of effort in each group", .before = "Effort.trend")

choice.con.inter.eg <- as.data.frame(choice.con.inter.eg[["contrasts"]]) %>% 
  add_column(term = "Effort*group interaction", .before = "contrast")

choice.con.inter.ar <- emtrends(m.choice.best, pairwise ~ Recipient_s2z, var = "Reward", adjust = "none", type = "response")

choice.con.ar <- as.data.frame(choice.con.inter.ar[["emtrends"]]) %>% 
  add_column(term = "Effect of reward for each recipient", .before = "Reward.trend")

choice.con.inter.ar <- as.data.frame(choice.con.inter.ar[["contrasts"]]) %>% 
  add_column(term = "Recipient*reward interaction", .before = "contrast")

choice.con.inter.ag <- contrast(contrast(emmeans(m.choice.best, ~ Recipient_s2z | Group_vmpfc), adjust = "none", 'pairwise'), 
                                'pairwise', by=NULL, adjust = "none", type = "response")
choice.con.inter.ag <- as.data.frame(choice.con.inter.ag) %>% 
  add_column(term = "Recipient*group interaction", .before = "contrast")

choice.con.all <- bind_rows(choice.con.ag1, choice.con.ag2, choice.con.ag3, choice.con.inter.ag, choice.con.inter.eg, choice.con.inter.ar) %>% 
  select(!c(df, estimate))

```

```{r choice-sig, echo = FALSE, cache = TRUE, warning=FALSE}

choice.sig <- array(NA,c(5,length(sig.order)))
i <- 1

# comparing recipients for each group
if (choice.con.ag$p.value[choice.con.ag$contrast == "self HC / other HC"] < .05) { choice.sig[1,1] <- "*" 
} else if (choice.con.ag$p.value[choice.con.ag$contrast == "self HC / other HC"] >= .05) {choice.sig[1,1] <- NA }
i <- i + 1
if (choice.con.ag$p.value[choice.con.ag$contrast == "self vmPFC / other vmPFC"] < .05) { choice.sig[1,2] <- "*" 
} else if (choice.con.ag$p.value[choice.con.ag$contrast == "self vmPFC / other vmPFC"] >= .05) {choice.sig[1,2] <- NA } 
i <- i + 1
if (choice.con.ag$p.value[choice.con.ag$contrast == "self LC / other LC"] < .05) { choice.sig[1,3] <- "*" 
} else if (choice.con.ag$p.value[choice.con.ag$contrast == "self LC / other LC"] >= .05) {choice.sig[1,3] <- NA }
i <- i + 1

# comparing self - other difference between groups [see below if error here]
if (choice.con.inter.ag$p.value[choice.con.inter.ag$contrast == "(self / other vmPFC) / (self / other HC)"] < .05) { choice.sig[1,i] <- "*"
} else if (choice.con.inter.ag$p.value[choice.con.inter.ag$contrast == "(self / other vmPFC) / (self / other HC)"] >= .05) { choice.sig[1,i] <- NA }
i <- i + 1
if (choice.con.inter.ag$p.value[choice.con.inter.ag$contrast == "(self / other vmPFC) / (self / other LC)"] < .05) { choice.sig[1,5] <- "*"
} else if (choice.con.inter.ag$p.value[choice.con.inter.ag$contrast == "(self / other vmPFC) / (self / other LC)"] >= .05) { choice.sig[1,i] <- NA }
i <- i + 1
if (choice.con.inter.ag$p.value[choice.con.inter.ag$contrast == "(self / other HC) / (self / other LC)"] < 0.05) { choice.sig[1,i] <- "*"
} else if (choice.con.inter.ag$p.value[choice.con.inter.ag$contrast == "(self / other HC) / (self / other LC)"] >= .05) { choice.sig[1,i] <- NA }
i <- i + 1

## depending on package versions notation may use "-" instead of "/" in section above
# comparing self - other difference between groups
# if (choice.con.inter.ag$p.value[choice.con.inter.ag$contrast == "(self - other vmPFC) - (self - other HC)"] < .05) { choice.sig[1,i] <- "*"
# } else if (choice.con.inter.ag$p.value[choice.con.inter.ag$contrast == "(self - other vmPFC) - (self - other HC)"] >= .05) { choice.sig[1,i] <- NA }
# i <- i + 1
# if (choice.con.inter.ag$p.value[choice.con.inter.ag$contrast == "(self - other vmPFC) - (self - other LC)"] < .05) { choice.sig[1,5] <- "*"
# } else if (choice.con.inter.ag$p.value[choice.con.inter.ag$contrast == "(self - other vmPFC) - (self - other LC)"] >= .05) { choice.sig[1,i] <- NA }
# i <- i + 1
# if (choice.con.inter.ag$p.value[choice.con.inter.ag$contrast == "(self - other HC) - (self - other LC)"] < 0.05) { choice.sig[1,i] <- "*"
# } else if (choice.con.inter.ag$p.value[choice.con.inter.ag$contrast == "(self - other HC) - (self - other LC)"] >= .05) { choice.sig[1,i] <- NA }
# i <- i + 1

colnames(choice.sig) <- sig.order

```

### Bayesian tests on choices

```{r choice-bf, echo = FALSE, cache = TRUE, warning=FALSE}

choices <-
  df                %>%
  dplyr::group_by(PM_ID, Group, Recipient)        %>%
  dplyr::summarise(prop_accept = mean(as.numeric(Choice)-1), num_choices = n(), .groups = "drop") %>% 
  mutate(Condition = interaction(Group, Recipient, sep = ":")) %>% 
  mutate(Condition = factor(Condition)) %>% 
  mutate(Condition2 = interaction(Recipient, Group, sep = ":")) %>% 
  mutate(Condition2 = factor(Condition2))

choices.bf10.hc.vmpfc.self <- ttestBF(choices$prop_accept[choices$Condition == "HC:self"], 
                                      choices$prop_accept[choices$Condition == "vmPFC:self"])
choices.bf01.hc.vmpfc.self <- 1 / choices.bf10.hc.vmpfc.self
choices.bf01.hc.vmpfc.self <- extractBF(choices.bf01.hc.vmpfc.self)

choices.bf10.hc.vmpfc.other <- ttestBF(choices$prop_accept[choices$Condition == "HC:other"], 
                                       choices$prop_accept[choices$Condition == "vmPFC:other"])
choices.bf01.hc.vmpfc.other <- 1 / choices.bf10.hc.vmpfc.other
choices.bf01.hc.vmpfc.other <- extractBF(choices.bf01.hc.vmpfc.other)

choices.bf10.lc.vmpfc.self <- ttestBF(choices$prop_accept[choices$Condition == "LC:self"], 
                                      choices$prop_accept[choices$Condition == "vmPFC:self"])
choices.bf01.lc.vmpfc.self <- 1 / choices.bf10.lc.vmpfc.self
choices.bf01.lc.vmpfc.self <- extractBF(choices.bf01.lc.vmpfc.self)

choices.bf10.lc.vmpfc.other <- ttestBF(choices$prop_accept[choices$Condition == "LC:other"], 
                                       choices$prop_accept[choices$Condition == "vmPFC:other"])
choices.bf01.lc.vmpfc.other <- 1 / choices.bf10.lc.vmpfc.other
choices.bf01.lc.vmpfc.other <- extractBF(choices.bf01.lc.vmpfc.other)

choices.bf10.hc.lc.self <- ttestBF(choices$prop_accept[choices$Condition == "HC:self"], 
                                   choices$prop_accept[choices$Condition == "LC:self"])
choices.bf01.hc.lc.self <- 1 / choices.bf10.hc.lc.self
choices.bf01.hc.lc.self <- extractBF(choices.bf01.hc.lc.self)

choices.bf10.hc.lc.other <- ttestBF(choices$prop_accept[choices$Condition == "HC:other"], 
                                    choices$prop_accept[choices$Condition == "LC:other"])
choices.bf01.hc.lc.other <- 1 / choices.bf10.hc.lc.other
choices.bf01.hc.lc.other <- extractBF(choices.bf01.hc.lc.other)

```

### Plot choice data

```{r choice-plot, warning=FALSE, message=FALSE, echo = FALSE, fig.height=6, fig.width=6}

### Group * agent interaction

choice.sig[2,] <- c(0.95,0.95,0.95,1.08,1.15,1.15) 
choice.sig[3,] <- c(hc.self.x, vmpfc.self.x, lc.self.x, hc.x, vmpfc.x, hc.x) 
choice.sig[4,] <- c(hc.other.x, vmpfc.other.x, lc.other.x, vmpfc.x, lc.x, lc.x)
choice.sig[5,] <- c(0, 0, 0, 0.02, 0.02, 0.02)

graphname <- paste0(path,'/Total_accept.tiff')  

if (saveplots == 1) {tiff(graphname, units="in", width = plotW*2, height = plotH, res = resolution)}

choice.plt <- ggplot(choices, aes(x=Condition2, y=prop_accept, fill = Recipient, color = Recipient, alpha = Condition, size = Condition)) +
  stat_summary(fun = mean, geom = "bar", position=position_dodge(0.75), width = 0.75, alpha = 1, color = 'black') +
  geom_line(aes(group = PM_ID), position = pd, colour = "grey", alpha = 0.5) +
  geom_point(aes(group = PM_ID), position = pd, size = 3, alpha = 0.5, show.legend = FALSE) +
  stat_summary(fun = mean, geom = "bar", position=position_dodge(0.75), width = 0.75, alpha = 0, color = 'black') +
  stat_summary(fun.data = "mean_cl_boot", geom = "errorbar", conf.int=.95, position=position_dodge(0.75), width = 0, color = 'black', alpha = 1) +
  scale_x_discrete(name = '', limits = inter.lims2, labels = inter.labs2) +
  scale_y_continuous(name = "Proportion accept", limits = lims, expan = expansion(mult = c(0, 0.1)), breaks = c(0.25,0.5,0.75,1)) +
  scale_size_manual(limits = inter.lims, values = sizes, guide = 'none') +
  scale_alpha_manual(limits = inter.lims, values = alphas, guide = 'none') +
  scale_fill_manual(limits = agent.lims, values = agent.fills, labels = agent.labs) +
  scale_color_manual(limits = agent.lims, values = agent.colours, labels = agent.labs) +
  theme_classic() +
  theme(legend.position = 'bottom',
        legend.margin=margin(0,0,0,0),
        legend.box.margin=margin(0,0,0,0),
        legend.box.spacing = unit(0, "pt"),
        legend.title = element_blank(),
        axis.text=element_text(size = axtext), 
        axis.text.x=element_text(size = axtext),
        axis.title.y=element_markdown(size = axtitle),
        legend.text=element_text(size = axtitle))

  for (c in 1:ncol(choice.sig)){
    choice.plt <- choice.plt + geom_signif(annotation = choice.sig[1,c], y_position = as.numeric(choice.sig[2,c]),
                                           xmin = as.numeric(choice.sig[3,c]), xmax = as.numeric(choice.sig[4,c]),
                                           tip_length = as.numeric(choice.sig[5,c]), colour = 'black', textsize = 7)}

# print(choice.plt)

choice.lab <- ggplot() +
  geom_textbox(mapping = aes(0.85, 0.25,
                             label = "<span style='font-size:14pt'>← <i>Rest more</i><span>", text.color = "black", orientation = "left-rotated",
                             box.color = "transparent", hjust = 0, vjust = 0.5, halign = 0), width = unit(0.47, "npc")) +
  geom_textbox(mapping = aes(0.85, 0.85,
                             label = "<span style='font-size:14pt'><i>Work more</i> →<span>", text.color = "black", orientation = "left-rotated",
                             box.color = "transparent", hjust = 0.9, vjust = 0.5, halign = 1), width = unit(0.47, "npc")) +
  xlim(0, 1) +
  theme_classic() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.x = element_blank(),
        axis.line.x = element_blank(),
        axis.title.y = element_blank(),
        axis.line.y = element_blank())

choice.lab.high <- plot_grid(choice.lab, NA, nrow = 2, rel_heights = c(1,0.1))

choice.plt <- plot_grid(choice.lab.high, choice.plt, ncol = 2, rel_widths = c(0.15,1))

if (saveplots == 1) {
  choice.plt
  dev.off()}

```

```{r choice-2way-plots, warning=FALSE, message=FALSE, echo = FALSE, fig.height=6, fig.width=6}

### Group * reward interaction (across agents)

choices.r <-
  df                %>%
  dplyr::group_by(PM_ID, Group, Reward.r)        %>%
  dplyr::summarise(prop_accept = mean(as.numeric(Choice)-1), .groups = "drop")

graphname <- paste0('plots/Reward_accept.tiff')  

if (saveplots == 1) {tiff(graphname, units="in", width = plotW*2, height = plotH, res = resolution)}

choice.r.plt <- ggplot(df, aes(x=Reward.r, y=Choice.r, group = Group, colour = Group, fill = Group, linetype = Group)) +
  stat_smooth(alpha = 0.3, size = 1, formula = y ~ x, method = "glm", method.args = list(family="binomial")) +
  stat_smooth(alpha = 0, size = 1, formula = y ~ x, method = "glm", method.args = list(family="binomial")) +
  scale_x_continuous(name = 'Reward level') + 
  scale_y_continuous(name = "Proportion accept") +
  coord_cartesian(ylim = c(0,1)) +
  scale_linetype_manual(limits = group.lims, values = c("dashed", "solid", "dotted"), labels = group.labs.leg) +
  scale_size_manual(limits = group.lims, values = sizes, guide = 'none') +
  scale_fill_manual(limits = group.lims, values = group.fills, labels = group.labs.leg) +
  scale_color_manual(limits = group.lims, values = group.colours, labels = group.labs.leg) +
  guides(linetype = guide_legend(override.aes = list(size = 0.7))) +
  theme_classic() +
  theme(legend.position = c(0.5,0.25), 
        legend.background = element_rect(fill='transparent'),
        legend.spacing = unit(0.1,"in"),
        legend.title = element_blank(),
        axis.text=element_text(size = axtext), 
        axis.title=element_text(size = axtitle),
        legend.text=element_text(size = axtitle)) +
  guides(fill = guide_legend(byrow = TRUE),
         color = guide_legend(byrow = TRUE),
         linetype = guide_legend(byrow = TRUE)) 

choice.r.plt <- plot_grid(choice.lab.high, choice.r.plt, ncol = 2, rel_widths = c(0.15,1))

# choice.r.plt

if (saveplots == 1) {dev.off()}

### Group * effort interaction (across agents)

choices.e <-
  df                %>%
  dplyr::group_by(PM_ID, Group, Effort.raw)        %>%
  dplyr::summarise(prop_accept = mean(as.numeric(Choice)-1), .groups = "drop")

graphname <- paste0(path,'/Effort_accept.tiff')

if (saveplots == 1) {tiff(graphname, units="in", width = plotW*2, height = plotH, res = resolution)}

choice.e.plt <- ggplot(df, aes(x=Effort.raw, y=Choice.r, group = Group, colour = Group, fill = Group, linetype = Group)) +
  stat_smooth(alpha = 0.3, size = 1, formula = y ~ x, method = "glm", method.args = list(family="binomial")) +
  stat_smooth(alpha = 0, size = 1, formula = y ~ x, method = "glm", method.args = list(family="binomial")) +
  scale_x_continuous(name = 'Effort level') + 
  scale_y_continuous(name = "Proportion accept") +
  coord_cartesian(ylim = c(0,1)) +
  scale_linetype_manual(limits = group.lims, values = c("dashed", "solid", "dotted"), labels = group.labs.leg) +
  scale_size_manual(limits = group.lims, values = sizes, guide = 'none') +
  scale_fill_manual(limits = group.lims, values = group.fills, labels = group.labs.leg) +
  scale_color_manual(limits = group.lims, values = group.colours, labels = group.labs.leg) +
  guides(linetype = guide_legend(override.aes = list(size = 0.7))) +
  annotate("text", x = 2, y = 1, label = "*", size = 7) + 
  annotate("text", x = 3, y = 1, label = "*", size = 7) + 
  annotate("text", x = 4, y = 1, label = "*", size = 7) + 
  theme_classic() +
  theme(legend.position = c(0.5,0.25), 
        legend.background = element_rect(fill='transparent'),
        legend.spacing = unit(0.1,"in"),
        legend.title = element_blank(),
        axis.text=element_text(size = axtext), 
        axis.title=element_text(size = axtitle),
        legend.text=element_text(size = axtitle)) +
  guides(fill = guide_legend(byrow = TRUE),
         color = guide_legend(byrow = TRUE),
         linetype = guide_legend(byrow = TRUE))

choice.e.plt <- plot_grid(choice.lab.high, choice.e.plt, ncol = 2, rel_widths = c(0.15,1))

# choice.e.plt

if (saveplots == 1) {dev.off()}

```

## Computational modelling results

### Plot model comparison

```{r model-comp-plot, echo = FALSE, warning=FALSE}

d.rel.bic <- read.csv('data/PM_model_fit_statistics_all.csv')

plot.bic <- ggplot(d.rel.bic, aes(x = as.factor(model), y = bicint, fill = choiceProbMedianR2)) + 
  geom_bar(stat = "identity", size = 0.3, colour = 'black',
           position=position_dodge(0.5), width = 0.5) +
  scale_y_continuous(name = "Integrated BIC") +
  scale_x_discrete(name = 'Model', breaks = c(1:12), labels = models) + 
  # scale_linetype_manual(values = c('solid', 'blank'), guide = 'none') +
  scale_fill_distiller(palette = "Purples", direction = 1) +
  guides(fill = guide_colourbar(title="R<sup>2</sup>",
                                title.position = 'right', title.hjust = 0.5,
                                frame.colour = NULL, barheight = 16,
                                ticks.colour = 'black', ticks.linewidth = 0.5,
                                draw.ulim = FALSE, draw.llim = FALSE)) +
  theme_classic() + 
  coord_cartesian(ylim = c(8300,10000)) +
  theme(legend.title = element_markdown(size = axtext), 
        legend.text = element_text(size = axtext),
        # legend.key.height = unit(0.5, "cm"),
        # legend.position = c(0.8,0.7),
        panel.background = element_rect(fill='transparent'),
        plot.background = element_rect(fill='transparent'),
        axis.text = element_text(size = axtext),
        axis.text.x = element_markdown(size = axtext, angle = 90, vjust = 0.5, hjust = 0),
        axis.title.x = element_text(size = axtitle),
        axis.title.y = element_text(size = axtitle))

# print(plot.bic)

bic.leg <- get_legend(plot.bic)

bic.plt <- plot.bic

bic.lab <- ggplot() +
  geom_textbox(mapping = aes(0.85, 0.25, 
                             label = "<span style='font-size:14pt'>← <i>Better fit</i><span>", text.color = "black", orientation = "left-rotated",
                             box.color = "transparent", hjust = 0, vjust = 0.5, halign = 0), width = unit(0.47, "npc")) +
  geom_textbox(mapping = aes(0.85, 0.85, 
                             label = "<span style='font-size:14pt'><i>Worse fit</i> →<span>", text.color = "black", orientation = "left-rotated",
                             box.color = "transparent", hjust = 0.9, vjust = 0.5, halign = 1), width = unit(0.47, "npc")) +
  xlim(0, 1) +
  theme_classic() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.x = element_blank(),
        axis.line.x = element_blank(),
        axis.title.y = element_blank(),
        axis.line.y = element_blank())

bic.lab <- plot_grid(bic.lab, NA, nrow = 2, rel_heights = c(1,0.1))
bic.leg <- plot_grid(NA, bic.leg, NA, nrow = 3, rel_heights = c(0.3,0.3,0.3))

graphname <- paste0(path,'/BIC_model_comp.tiff')  

if (saveplots == 1) {tiff(graphname, units="in", width = plotW*2, height = plotH*0.75, res = resolution)
  
  print(bic.plt)
  
  dev.off()}

```

### Plots of model identifiability, parameter recovery & model fit

```{r mi-pr, echo = FALSE, warning=FALSE, message=FALSE, fig.width=5, fig.height=plotH}

modplotW <- plotH * 1.55 # set up dimensions to save figure
modprplotW <- plotH * 1.63
modfitplotW <- modplotW * 1.3

## Model identifiability

df.mi <- read_csv("data/Model_identifiability_em.csv", col_names = T, show_col_types = FALSE)

df.mi <- df.mi %>%
  mutate(Simulated = factor(Simulated)) %>% 
  mutate(Estimated = factor(Estimated))

xp.plot <- ggplot(data = df.mi, aes(x=Simulated, y=Estimated, fill=xp)) +
  geom_tile() +
  scale_fill_distiller(palette = "PuBu", direction = 1,
                       limit = c(0,1), space = "Lab",
                       name="Exceedance probability") +
  guides(fill = guide_colorbar(title.position = 'right', title.hjust = 0.5,
                               frame.colour = NULL, barheight = 16,
                               ticks.colour = 'black', ticks.linewidth = 0.5,
                               draw.ulim = FALSE, draw.llim = FALSE)) +
  scale_x_discrete(breaks = c(1:12), labels = models) + 
  scale_y_discrete(breaks = c(1:12), labels = models) + 
  theme_classic() +
  theme(axis.text.x = element_markdown(size = axtext, angle = 90, vjust = 0.5, hjust = 0),
        axis.text.y = element_markdown(size = axtext, hjust = 0),
        axis.title = element_text(size = axtitle),
        legend.title = element_text(size = axtitle, angle = 90),
        legend.text = element_text(size = axtext))

if (saveplots == 1) {tiff("plots/Model_iden_xp.tiff", units="in", res = resolution, width = modplotW, height = plotH)
  
  xp.plot
  
  dev.off()}

bm.plot <- ggplot(data = df.mi, aes(x=Simulated, y=Estimated, fill=best)) +
  geom_tile() +
  scale_fill_distiller(palette = "PuBuGn", direction = 1,
                       limit = c(0,10), space = "Lab",
                       name="Best model (of 10)") +
  guides(fill = guide_colorbar(title.position = 'right', title.hjust = 0.5,
                               frame.colour = NULL, barheight = 16,
                               ticks.colour = 'black', ticks.linewidth = 0.5,
                               draw.ulim = FALSE, draw.llim = FALSE)) +
  scale_x_discrete(breaks = c(1:12), labels = models) + 
  scale_y_discrete(breaks = c(1:12), labels = models) + 
  theme_classic() +
  theme(axis.text.x = element_markdown(size = axtext, angle = 90, vjust = 0.5, hjust = 0),
        axis.text.y = element_markdown(size = axtext, hjust = 0),
        axis.title = element_text(size = axtitle),
        legend.title = element_text(size = axtitle, angle = 90),
        legend.text = element_text(size = axtext))

if (saveplots == 1) {tiff("plots/Model_iden_best.tiff", units="in", res = resolution, width = modplotW, height = plotH)
  
  bm.plot
  
  dev.off()}

## Parameter recovery

df.pr <- read_csv("data/Parameter_recovery_em.csv", col_names = T, show_col_types = FALSE)

df.pr$diag <- df.pr$Simulated == df.pr$Recovered
df.pr$diag[!df.pr$diag] <- NA

pal <- c("#F6E8C3", "#F5F5F5", "#C7EAE5", "#80CDC1", "#35978F", "#01665E", "#003C30") # create colour palette

ml.plot <- ggplot(data = df.pr, aes(x=Simulated, y=Recovered, fill=HCorr)) + 
  geom_tile() +
  scale_fill_gradientn(colours = pal,
                       limit = c(-0.25,1.05), 
                       name="R") +
  guides(fill = guide_colorbar(title.position = 'right', title.hjust = 0.5, 
                               frame.colour = NULL, barheight = 16, 
                               ticks.colour = 'black', ticks.linewidth = 0.5,  
                               draw.ulim = FALSE, draw.llim = FALSE, override.aes = list(limits = c(0,1)))) +
  scale_x_continuous(breaks = c(1,2,3,4),
                     labels = c(paste0("*\u039A*","<sub>self</sub>"), # rename models with k and beta symbols
                                paste0("*\u039A*","<sub>other</sub>"),
                                paste0("*\u03B2*","<sub>self</sub>"),
                                paste0("*\u03B2*","<sub>other</sub>"))) +
  scale_y_continuous(breaks = c(1,2,3,4),
                     labels = c(paste0("*\u039A*","<sub>self</sub>"), # rename models with k and beta symbols
                                paste0("*\u039A*","<sub>other</sub>"),
                                paste0("*\u03B2*","<sub>self</sub>"),
                                paste0("*\u03B2*","<sub>other</sub>"))) +
  theme_classic() + 
  theme(axis.text.x = element_markdown(size = axtext),
        axis.text.y = element_markdown(size = axtext), 
        axis.title = element_text(size = axtitle), 
        legend.title = element_text(size = axtitle), 
        legend.text = element_text(size = axtext))

if (saveplots == 1) {tiff("plots/Parameter_recovery.tiff", units="in", res = resolution, width = plotW*2, height = plotH*0.75)
  
  ml.plot
  
  dev.off()}

```

```{r k-sim, echo = FALSE, warning=FALSE, message=FALSE, fig.width=5, fig.height=plotH}

df.ksim <- read_csv("data/simulated_ks.csv", col_names = T, show_col_types = FALSE)

df.ksim <- df.ksim %>% 
  mutate(Group = factor(k))

### Effort effect for different k values

graphname <- paste0(path,'/k_stimulations.tiff')

if (saveplots == 1) {tiff(graphname, units="in", width = plotW*2, height = plotH, res = resolution)}

k.sim.plt <- ggplot(df.ksim, aes(x=effort, y=sv, group = Group, colour = k, fill = k)) +
  geom_line(size = 1, formula = y~x) +
  scale_x_continuous(name = 'Effort level') + 
  scale_y_continuous(name = "Subjective value") +
  guides(fill = guide_legend(title = '*\u039A*'), colour = guide_legend(title = '*\u039A*')) +
  theme_classic() +
  theme(legend.background = element_rect(fill='transparent'),
        legend.title = element_markdown(size = axtitle),
        axis.text=element_blank(), 
        axis.title=element_text(size = axtitle),
        legend.text=element_text(size = axtitle)) 

# k.sim.plt

if (saveplots == 1) {dev.off()}

k.sim.plt.lin <- ggplot(df.ksim, aes(x=effort, y=sv_lin, group = Group, colour = k, fill = k)) +
  geom_line(size = 1, formula = y~x) +
  scale_x_continuous(name = 'Effort level') + 
  scale_y_continuous(name = "Subjective value") +
  guides(fill = guide_legend(title = '*\u039A*'), colour = guide_legend(title = '*\u039A*')) +
  theme_classic() +
  theme(legend.background = element_rect(fill='transparent'),
        legend.title = element_markdown(size = axtitle),
        axis.text=element_blank(), 
        axis.title=element_text(size = axtitle),
        legend.text=element_text(size = axtitle)) 

# k.sim.plt.lin

k.sim.plt.hyp <- ggplot(df.ksim, aes(x=effort, y=sv_hyp, group = Group, colour = k, fill = k)) +
  geom_line(size = 1, formula = y~x) +
  scale_x_continuous(name = 'Effort level') + 
  scale_y_continuous(name = "Subjective value") +
  guides(fill = guide_legend(title = '*\u039A*'), colour = guide_legend(title = '*\u039A*')) +
  theme_classic() +
  theme(legend.background = element_rect(fill='transparent'),
        legend.title = element_markdown(size = axtitle),
        axis.text=element_blank(), 
        axis.title=element_text(size = axtitle),
        legend.text=element_text(size = axtitle)) 

# k.sim.plt.hyp

```

## Analyse `r "<i>\u039A</i>"` parameters

### Models of `r "<i>\u039A</i>"` parameters

```{r k-models, warning=FALSE, message=FALSE, echo=FALSE}

# ### Use generalised linear mixed-effects model to analyse the data with family & link function to account for skew

m.gam.log <- glmer(k ~ Recipient_s2z*Group_vmpfc + (1|ID), data = df.2kl, family = Gamma(link = 'log'), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))

m.k.best <- m.gam.log

r.k.full <- model_parameters(m.k.best, exponentiate = T)
r.k <- r.k.full %>%
  dplyr::filter(Effects == "fixed") %>%
  select(!c(df_error, Effects, Group, CI)) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Recipient_s2z1", replacement = "Recipient (Self vs. Other)")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Group_vmpfcHC", replacement = "Group (vmPFC vs. HC)")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Group_vmpfcLC", replacement = "Group (vmPFC vs. LC)")) %>%
  mutate(Parameter = str_replace_all(Parameter, pattern = ":", replacement = " * "))

```

### Post-hoc tests on `r "<i>\u03B2</i>"` parameters

```{r k-posthocs, echo = FALSE, cache = TRUE, warning=FALSE, message=FALSE}

k.con.ag <- contrast(emmeans(m.k.best, ~ Recipient_s2z | Group_vmpfc), 'pairwise', by=NULL, adjust = "none", type = "response")
k.con.ag <- as.data.frame(k.con.ag)

k.con.ag1 <- k.con.ag %>% 
  subset(contrast == "self vmPFC / self HC" | contrast == "self vmPFC / self LC" | contrast == "self HC / self LC") %>% 
  add_column(term = "Effect of group for self", .before = "contrast")

k.con.ag2 <- k.con.ag %>% 
  subset(contrast == "other vmPFC / other HC" | contrast == "other vmPFC / other LC" | contrast == "other HC / other LC") %>% 
  add_column(term = "Effect of group for other", .before = "contrast")

k.con.ag3 <- k.con.ag %>% 
  subset(contrast == "self vmPFC / other vmPFC" | contrast == "self HC / other HC" | contrast == "self LC / other LC") %>% 
  add_column(term = "Effect of recipient in each group", .before = "contrast")

k.con.inter <- contrast(contrast(emmeans(m.k.best, ~ Recipient_s2z | Group_vmpfc), 'pairwise'), 'pairwise', by=NULL, adjust = "none", type = "response")
k.con.inter <- as.data.frame(k.con.inter) %>% 
  add_column(term = "Recipient*group interaction", .before = "contrast")

k.con.all <- bind_rows(k.con.ag1, k.con.ag2, k.con.ag3, k.con.inter) %>% 
  select(!c(df))

```

```{r k-sig, echo = FALSE, cache = TRUE, warning=FALSE}

k.sig <- array(NA,c(5,length(sig.order)))
i <- 1

# comparing recipients for each group
if (k.con.ag$p.value[k.con.ag$contrast == "self HC / other HC"] < .05) { k.sig[1,1] <- "*" 
} else if (k.con.ag$p.value[k.con.ag$contrast == "self HC / other HC"] >= .05) {k.sig[1,1] <- NA }
i <- i + 1
if (k.con.ag$p.value[k.con.ag$contrast == "self vmPFC / other vmPFC"] < .05) { k.sig[1,2] <- "*" 
} else if (k.con.ag$p.value[k.con.ag$contrast == "self vmPFC / other vmPFC"] >= .05) {k.sig[1,2] <- NA } 
i <- i + 1
if (k.con.ag$p.value[k.con.ag$contrast == "self LC / other LC"] < .05) { k.sig[1,3] <- "*" 
} else if (k.con.ag$p.value[k.con.ag$contrast == "self LC / other LC"] >= .05) {k.sig[1,3] <- NA }
i <- i + 1

# comparing self - other difference between groups
if (k.con.inter$p.value[k.con.inter$contrast == "(self / other vmPFC) / (self / other HC)"] < .05) { k.sig[1,i] <- "*" 
} else if (k.con.inter$p.value[k.con.inter$contrast == "(self / other vmPFC) / (self / other HC)"] >= .05) { k.sig[1,i] <- NA } 
i <- i + 1
if (k.con.inter$p.value[k.con.inter$contrast == "(self / other vmPFC) / (self / other LC)"] < .05) { k.sig[1,5] <- "*" 
} else if (k.con.inter$p.value[k.con.inter$contrast == "(self / other vmPFC) / (self / other LC)"] >= .05) { k.sig[1,i] <- NA }
i <- i + 1
if (k.con.inter$p.value[k.con.inter$contrast == "(self / other HC) / (self / other LC)"] < 0.05) { k.sig[1,i] <- "*" 
} else if (k.con.inter$p.value[k.con.inter$contrast == "(self / other HC) / (self / other LC)"] >= .05) {k.sig[1,i] <- NA } 
i <- i + 1

colnames(k.sig) <- sig.order

```

### Bayesian tests on `r "<i>\u039A</i>"` parameters

```{r k-bf, echo = FALSE, cache = TRUE, warning=FALSE}

k.bf10.hc.vmpfc.self <- ttestBF(df.2kl$k[df.2kl$Condition == "self:HC"], 
                                df.2kl$k[df.2kl$Condition == "self:vmPFC"])
k.bf01.hc.vmpfc.self <- 1 / k.bf10.hc.vmpfc.self
k.bf01.hc.vmpfc.self <- extractBF(k.bf01.hc.vmpfc.self)

k.bf10.hc.vmpfc.other <- ttestBF(df.2kl$k[df.2kl$Condition == "other:HC"], 
                                 df.2kl$k[df.2kl$Condition == "other:vmPFC"])
k.bf01.hc.vmpfc.other <- 1 / k.bf10.hc.vmpfc.other
k.bf01.hc.vmpfc.other <- extractBF(k.bf01.hc.vmpfc.other)

k.bf10.lc.vmpfc.self <- ttestBF(df.2kl$k[df.2kl$Condition == "self:LC"], 
                                df.2kl$k[df.2kl$Condition == "self:vmPFC"])
k.bf01.lc.vmpfc.self <- 1 / k.bf10.lc.vmpfc.self
k.bf01.lc.vmpfc.self <- extractBF(k.bf01.lc.vmpfc.self)

k.bf10.lc.vmpfc.other <- ttestBF(df.2kl$k[df.2kl$Condition == "other:LC"], 
                                 df.2kl$k[df.2kl$Condition == "other:vmPFC"])
k.bf01.lc.vmpfc.other <- 1 / k.bf10.lc.vmpfc.other
k.bf01.lc.vmpfc.other <- extractBF(k.bf01.lc.vmpfc.other)

k.bf10.hc.lc.self <- ttestBF(df.2kl$k[df.2kl$Condition == "self:HC"], 
                             df.2kl$k[df.2kl$Condition == "self:LC"])
k.bf01.hc.lc.self <- 1 / k.bf10.hc.lc.self
k.bf01.hc.lc.self <- extractBF(k.bf01.hc.lc.self)

k.bf10.hc.lc.other <- ttestBF(df.2kl$k[df.2kl$Condition == "other:HC"], 
                              df.2kl$k[df.2kl$Condition == "other:LC"])
k.bf01.hc.lc.other <- 1 / k.bf10.hc.lc.other
k.bf01.hc.lc.other <- extractBF(k.bf01.hc.lc.other)

```

### Plot `r "<i>\u039A</i>"` parameters

```{r k-plot, echo = FALSE, warning=FALSE, fig.height=6, fig.width=6}

k.sig[2,] <- c(0.1,0.1,0.1,0.3,0.4,0.4)
k.sig[3,] <- c(hc.self.x, vmpfc.self.x, lc.self.x, hc.x, vmpfc.x, hc.x)
k.sig[4,] <- c(hc.other.x, vmpfc.other.x, lc.other.x, vmpfc.x, lc.x, lc.x)
k.sig[5,] <- c(0, 0, 0, 0.02, 0.02, 0.02)

## plot k parameters

df.2kl <- df.2kl  %>% 
  mutate(ID = droplevels(ID)) %>% 
  dplyr::arrange(ID, Group, Recipient)        %>%
  mutate(Condition = interaction(Group, Recipient, sep = ":")) %>% 
  mutate(Condition = factor(Condition)) %>% 
  mutate(Condition2 = interaction(Recipient, Group, sep = ":")) %>% 
  mutate(Condition2 = factor(Condition2))

pd <- position_jitter(height = 0, width = 0.2, seed = 123)

k.plt <- ggplot(df.2kl, aes(x = Condition2, y = k, fill = Recipient, color = Recipient, alpha = Condition, size = Condition)) +
  stat_summary(fun = mean, geom = "bar", position=position_dodge(0.75), width = 0.75, alpha = 1, color = 'black') +
  geom_line(aes(group = ID), position = pd, colour = "grey", alpha = 0.5) +
  geom_point(aes(group = ID), position = pd, size = 3, alpha = 0.5, show.legend = FALSE) +
  stat_summary(fun = mean, geom = "bar", position=position_dodge(0.75), width = 0.75, alpha = 0, color = 'black') +
  stat_summary(fun.data = "mean_cl_boot", geom = "errorbar", conf.int=.95, position=position_dodge(0.75), width = 0, color = 'black', alpha = 1) +
  scale_x_discrete(name = '', limits = inter.lims2, labels = inter.labs2) +
  scale_y_continuous(name = klabel, trans = "reverse", breaks = c(1.5,1,0.5,0), limits = c(1.5, -0.5)) +
  scale_size_manual(limits = inter.lims, values = sizes, guide = 'none') +
  scale_alpha_manual(limits = inter.lims, values = alphas, guide = 'none') +
  scale_fill_manual(limits = agent.lims, values = agent.fills, labels = agent.labs) +
  scale_color_manual(limits = agent.lims, values = agent.colours, labels = agent.labs) +
  theme_classic() +
  theme(legend.margin=margin(0,0,0,0),
        panel.background = element_rect(fill='transparent'),
        plot.background = element_rect(fill='transparent'),
        legend.box.margin=margin(0,0,0,0),
        legend.box.spacing = unit(0, "pt"),
        legend.title = element_blank(),
        axis.text=element_text(size = axtext), 
        axis.text.x=element_text(size = axtext),
        axis.title.y=element_markdown(size = axtitle),
        legend.text=element_text(size = axtitle))

for (c in 1:ncol(k.sig)){
  k.plt <- k.plt + geom_signif(annotation = k.sig[1,c], y_position = as.numeric(k.sig[2,c]),
                               xmin = as.numeric(k.sig[3,c]), xmax = as.numeric(k.sig[4,c]),
                               tip_length = as.numeric(k.sig[5,c]), colour = 'black', textsize = 7)}
# print(k.plt)

k.lab <- ggplot() +
  geom_textbox(mapping = aes(0.85, 0.25,
                             label = "<span style='font-size:14pt'>← <i>Discount more</i><span>", text.color = "black", orientation = "left-rotated",
                             box.color = "transparent", hjust = 0, vjust = 0.5, halign = 0), width = unit(0.47, "npc")) +
  geom_textbox(mapping = aes(0.85, 0.85,
                             label = "<span style='font-size:14pt'><i>Discount less</i> →<span>", text.color = "black", orientation = "left-rotated",
                             box.color = "transparent", hjust = 0.9, vjust = 0.5, halign = 1), width = unit(0.47, "npc")) +
  xlim(0, 1) +
  theme_classic() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.x = element_blank(),
        axis.line.x = element_blank(),
        axis.title.y = element_blank(),
        axis.line.y = element_blank())

k.lab.high <- plot_grid(k.lab, NA, nrow = 2, rel_heights = c(1,0.1))

graphname <- paste0(path,'/K.tiff')  

if (saveplots == 1) {tiff(graphname, units="in", width = plotW*2, height = plotH, res = resolution)
  
  print(k.plt)
  
  dev.off()}

```

## Analyse `r "<i>\u03B2</i>"` parameters

### Models of `r "<i>\u03B2</i>"` parameters

```{r beta-models, warning=FALSE, message=FALSE, echo=FALSE}

m.beta <- lmer(beta ~ Recipient_s2z*Group_vmpfc + (1|ID), data = df.2kl, control=lmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))

r.beta.full <- model_parameters(m.beta, standardize = "refit", exponentiate = T)
r.beta <- r.beta.full %>%
  dplyr::filter(Effects == "fixed") %>%
  select(!c(df_error, Effects, Group, CI)) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Recipient_s2z1", replacement = "Recipient (Self vs. Other)")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Group_vmpfcHC", replacement = "Group (vmPFC vs. HC)")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Group_vmpfcLC", replacement = "Group (vmPFC vs. LC)")) %>%
  mutate(Parameter = str_replace_all(Parameter, pattern = ":", replacement = " * "))

beta.con.agent <- contrast(emmeans(m.beta, ~ Recipient_s2z), 'pairwise', by=NULL, adjust = "none", type = "response")
beta.con.agent <- as.data.frame(beta.con.agent) %>% 
  add_column(term = "Effect of recipient", .before = "contrast")

beta.con.group <- contrast(emmeans(m.beta, ~ Group_vmpfc), 'pairwise', by=NULL, adjust = "none", type = "response")
beta.con.group <- as.data.frame(beta.con.group )%>% 
  add_column(term = "Effect of group", .before = "contrast")

beta.con.ag <- contrast(emmeans(m.beta, ~ Recipient_s2z | Group_vmpfc), 'pairwise', by=NULL, adjust = "none", type = "response")
beta.con.ag <- as.data.frame(beta.con.ag)
beta.con.ag <- beta.con.ag %>% 
  subset(contrast == "self vmPFC - other vmPFC" | contrast == "self HC - other HC" | contrast == "self LC - other LC") %>% 
  add_column(term = "Effect of recipient in each group", .before = "contrast")

beta.con.inter <- contrast(contrast(emmeans(m.beta, ~ Recipient_s2z | Group_vmpfc), 'pairwise'), 'pairwise', by=NULL, adjust = "none", type = "response")
beta.con.inter <- as.data.frame(beta.con.inter) %>% 
  add_column(term = "Recipient*group interaction", .before = "contrast")

beta.con.all <- bind_rows(beta.con.agent, beta.con.group) %>%
  select(!c(df))

```

```{r beta-sig, echo = FALSE, cache = TRUE, warning=FALSE}

beta.sig <- array(NA,c(5,length(sig.order)))
i <- 1

# comparing recipients for each group
if (beta.con.ag$p.value[beta.con.ag$contrast == "self HC - other HC"] < .05) { beta.sig[1,1] <- "*" 
} else if (beta.con.ag$p.value[beta.con.ag$contrast == "self HC - other HC"] >= .05) {beta.sig[1,1] <- NA }
i <- i + 1
if (beta.con.ag$p.value[beta.con.ag$contrast == "self vmPFC - other vmPFC"] < .05) { beta.sig[1,2] <- "*" 
} else if (beta.con.ag$p.value[beta.con.ag$contrast == "self vmPFC - other vmPFC"] >= .05) {beta.sig[1,2] <- NA } 
i <- i + 1
if (beta.con.ag$p.value[beta.con.ag$contrast == "self LC - other LC"] < .05) { beta.sig[1,3] <- "*" 
} else if (beta.con.ag$p.value[beta.con.ag$contrast == "self LC - other LC"] >= .05) {beta.sig[1,3] <- NA }
i <- i + 1

# comparing self - other difference between groups
if (beta.con.inter$p.value[beta.con.inter$contrast == "(self - other vmPFC) - (self - other HC)"] < .05) { beta.sig[1,i] <- "*" 
} else if (beta.con.inter$p.value[beta.con.inter$contrast == "(self - other vmPFC) - (self - other HC)"] >= .05) { beta.sig[1,i] <- NA } 
i <- i + 1
if (beta.con.inter$p.value[beta.con.inter$contrast == "(self - other vmPFC) - (self - other LC)"] < .05) { beta.sig[1,5] <- "*" 
} else if (beta.con.inter$p.value[beta.con.inter$contrast == "(self - other vmPFC) - (self - other LC)"] >= .05) { beta.sig[1,i] <- NA }
i <- i + 1
if (beta.con.inter$p.value[beta.con.inter$contrast == "(self - other HC) - (self - other LC)"] < 0.05) { beta.sig[1,i] <- "*" 
} else if (beta.con.inter$p.value[beta.con.inter$contrast == "(self - other HC) - (self - other LC)"] >= .05) { beta.sig[1,i] <- NA } 
i <- i + 1

colnames(beta.sig) <- sig.order

```

### Bayesian tests on `r "<i>\u03B2</i>"` parameters

```{r beta-bf, echo = FALSE, cache = TRUE, warning=FALSE}

beta.bf10.hc.vmpfc.self <- ttestBF(df.2kl$beta[df.2kl$Condition2 == "self:HC"], 
                                df.2kl$beta[df.2kl$Condition2 == "self:vmPFC"])
beta.bf01.hc.vmpfc.self <- 1 / beta.bf10.hc.vmpfc.self
beta.bf01.hc.vmpfc.self <- extractBF(beta.bf01.hc.vmpfc.self)

beta.bf10.hc.vmpfc.other <- ttestBF(df.2kl$beta[df.2kl$Condition2 == "other:HC"], 
                                 df.2kl$beta[df.2kl$Condition2 == "other:vmPFC"])
beta.bf01.hc.vmpfc.other <- 1 / beta.bf10.hc.vmpfc.other
beta.bf01.hc.vmpfc.other <- extractBF(beta.bf01.hc.vmpfc.other)

beta.bf10.lc.vmpfc.self <- ttestBF(df.2kl$beta[df.2kl$Condition2 == "self:LC"], 
                                df.2kl$beta[df.2kl$Condition2 == "self:vmPFC"])
beta.bf01.lc.vmpfc.self <- 1 / beta.bf10.lc.vmpfc.self
beta.bf01.lc.vmpfc.self <- extractBF(beta.bf01.lc.vmpfc.self)

beta.bf10.lc.vmpfc.other <- ttestBF(df.2kl$beta[df.2kl$Condition2 == "other:LC"], 
                                 df.2kl$beta[df.2kl$Condition2 == "other:vmPFC"])
beta.bf01.lc.vmpfc.other <- 1 / beta.bf10.lc.vmpfc.other
beta.bf01.lc.vmpfc.other <- extractBF(beta.bf01.lc.vmpfc.other)

beta.bf10.hc.lc.self <- ttestBF(df.2kl$beta[df.2kl$Condition2 == "self:HC"], 
                             df.2kl$beta[df.2kl$Condition2 == "self:LC"])
beta.bf01.hc.lc.self <- 1 / beta.bf10.hc.lc.self
beta.bf01.hc.lc.self <- extractBF(beta.bf01.hc.lc.self)

beta.bf10.hc.lc.other <- ttestBF(df.2kl$beta[df.2kl$Condition2 == "other:HC"], 
                              df.2kl$beta[df.2kl$Condition2 == "other:LC"])
beta.bf01.hc.lc.other <- 1 / beta.bf10.hc.lc.other
beta.bf01.hc.lc.other <- extractBF(beta.bf01.hc.lc.other)

```

### Plot `r "<i>\u03B2</i>"` parameters

```{r beta-plot, echo = FALSE, warning=FALSE, fig.height=6, fig.width=6}

beta.sig[2,] <- c(2.7,2.7,2.7,2.9,3.1,3.1) 
beta.sig[3,] <- c(hc.self.x, vmpfc.self.x, lc.self.x, hc.x, vmpfc.x, hc.x) 
beta.sig[4,] <- c(hc.other.x, vmpfc.other.x, lc.other.x, vmpfc.x, lc.x, lc.x)
beta.sig[5,] <- c(0, 0, 0, 0.02, 0.02, 0.02)

## plot beta parameters

b.plt <- ggplot(df.2kl, aes(x = Condition2, y = beta, group = Recipient, fill = Recipient, color = Recipient, alpha = Condition)) +
  stat_summary(fun = mean, geom = "bar", position=position_dodge(0.75), width = 0.75, alpha = 1, color = 'black') +
  geom_line(aes(group = ID), position = pd, colour = "grey", alpha = 0.5) +
  geom_point(aes(group = ID), position = pd, size = 3, alpha = 0.5, show.legend = FALSE) +
  stat_summary(fun = mean, geom = "bar", position=position_dodge(0.75), width = 0.75, alpha = 0, color = 'black') +
  stat_summary(fun.data = "mean_cl_boot", geom = "errorbar", conf.int=.95, position=position_dodge(0.75), width = 0, color = 'black', alpha = 1) +
  scale_x_discrete(name = '', limits = inter.lims2, labels = inter.labs2) +
  scale_y_continuous(name = blabel, expan = expansion(mult = c(0, 0.1))) +
  scale_alpha_manual(limits = inter.lims, values = alphas, guide = 'none') +
  scale_fill_manual(limits = agent.lims, values = agent.fills, labels = agent.labs) +
  scale_color_manual(limits = agent.lims, values = agent.colours, labels = agent.labs) +
  theme_classic() +
  theme(legend.margin=margin(0,0,0,0),
        panel.background = element_rect(fill='transparent'),
        plot.background = element_rect(fill='transparent'),
        legend.box.margin=margin(0,0,0,0),
        legend.box.spacing = unit(0, "pt"),
        legend.title = element_blank(),
        axis.text=element_text(size = axtext), 
        axis.text.x=element_text(size = axtext),
        axis.title.y=element_markdown(size = axtitle),
        legend.text=element_text(size = axtitle))

for (c in 1:ncol(beta.sig)){
  b.plt <- b.plt + geom_signif(annotation = beta.sig[1,c], y_position = as.numeric(beta.sig[2,c]),
                               xmin = as.numeric(beta.sig[3,c]), xmax = as.numeric(beta.sig[4,c]),
                               tip_length = as.numeric(beta.sig[5,c]), colour = 'black', textsize = 7)}
# print(b.plt)

b.lab <- ggplot() +
  geom_textbox(mapping = aes(0.85, 0.25,
                             label = "<span style='font-size:14pt'>← <i>Less consistent</i><span>", text.color = "black", orientation = "left-rotated",
                             box.color = "transparent", hjust = 0, vjust = 0.5, halign = 0), width = unit(0.47, "npc")) +
  geom_textbox(mapping = aes(0.85, 0.85,
                             label = "<span style='font-size:14pt'><i>More consistent</i> →<span>", text.color = "black", orientation = "left-rotated",
                             box.color = "transparent", hjust = 0.9, vjust = 0.5, halign = 1), width = unit(0.47, "npc")) +
  xlim(0, 1) +
  theme_classic() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.x = element_blank(),
        axis.line.x = element_blank(),
        axis.title.y = element_blank(),
        axis.line.y = element_blank()) 

b.lab <- plot_grid(b.lab, NA, nrow = 2, rel_heights = c(1,0.1))

b.plt <- plot_grid(b.lab, b.plt, ncol = 2, rel_widths = c(0.15,1))

graphname <- paste0(path,'/beta.tiff')  

if (saveplots == 1) {tiff(graphname, units="in", width = plotW*2, height = plotH, res = resolution)
  
  print(b.plt)}

if (saveplots == 1) {dev.off()}

```

## Analyse force data

```{r success-comparisons, echo=FALSE}

success <-
  df %>%
  dplyr::group_by(PM_ID, Group_vmpfc) %>%
  dplyr::summarise(mean_succ = mean(Success.r, na.rm = T), .groups = "drop")

df.success <-
  df %>%
  dplyr::group_by(Group_vmpfc, Recipient_s2z, PM_ID) %>%
  dplyr::summarise(mean_succ = mean(Success.r, na.rm = T), .groups = "drop")

```

### Models of success rates

```{r success-models, warning=FALSE, message=FALSE, echo=FALSE}

noother <- as.character(df.success$PM_ID[df.success$mean_succ == "NaN"])
success.a.nonan <- df.success
success.a.nonan$mean_succ[success.a.nonan$PM_ID == noother[1]]<- NA
success.a.nonan$mean_succ[success.a.nonan$PM_ID == noother[2]]<- NA

success.per <- 
  df.success %>%
  dplyr::group_by(Group_vmpfc, Recipient_s2z) %>%
  dplyr::summarise(mean_success = mean(mean_succ, na.rm = T) * 100, .groups = "drop")

# ### Use generalised linear mixed-effects model to analyse the data with family & link function to account for skew

m.success <- lmer(mean_succ ~ Recipient_s2z*Group_vmpfc + (1|PM_ID), data = df.success, control=lmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))

r.success.full <- model_parameters(m.success, standardize = "refit", )
r.success <- r.success.full %>%
  dplyr::filter(Effects == "fixed") %>%
  select(!c(df_error, Effects, Group, CI)) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Recipient_s2z1", replacement = "Recipient (Self vs. Other)")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Group_vmpfcHC", replacement = "Group (vmPFC vs. HC)")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Group_vmpfcLC", replacement = "Group (vmPFC vs. LC)")) %>%
  mutate(Parameter = str_replace_all(Parameter, pattern = ":", replacement = " * "))

success.bf.hc.self.other <- ttestBF(success.a.nonan$mean_succ[success.a.nonan$Group_vmpfc == "HC" & success.a.nonan$Recipient_s2z == "self" & !is.na(success.a.nonan$mean_succ)],
                                    success.a.nonan$mean_succ[success.a.nonan$Group_vmpfc == "HC" & success.a.nonan$Recipient_s2z == "other" & !is.na(success.a.nonan$mean_succ)], 
                                    paired = T)
success.bf01.hc.self.other <- 1 / success.bf.hc.self.other
success.bf01.hc.self.other <- extractBF(success.bf01.hc.self.other)

```

### Post-hoc tests on success rates

```{r success-posthocs, echo = FALSE, cache = TRUE, warning=FALSE, message=FALSE}

success.con.ag <- contrast(emmeans(m.success, ~ Recipient_s2z | Group_vmpfc), 'pairwise', by=NULL, adjust = "none")
success.con.ag <- as.data.frame(success.con.ag)

success.con.ag1 <- success.con.ag %>%
  subset(contrast == "self vmPFC - self HC" | contrast == "self vmPFC - self LC" | contrast == "self HC - self LC") %>%
  add_column(term = "Effect of group for self", .before = "contrast")

success.con.ag2 <- success.con.ag %>%
  subset(contrast == "other vmPFC - other HC" | contrast == "other vmPFC - other LC" | contrast == "other HC - other LC") %>%
  add_column(term = "Effect of group for other", .before = "contrast")

success.con.ag3 <- success.con.ag %>%
  subset(contrast == "self vmPFC - other vmPFC" | contrast == "self HC - other HC" | contrast == "self LC - other LC") %>%
  add_column(term = "Effect of recipient in each group", .before = "contrast")

success.con.inter <- contrast(contrast(emmeans(m.success, ~ Recipient_s2z | Group_vmpfc), 'pairwise'), 'pairwise', by=NULL, adjust = "none", type = "response")
success.con.inter <- as.data.frame(success.con.inter) %>% 
  add_column(term = "Recipient*group interaction", .before = "contrast")

success.con.all <- bind_rows(success.con.ag1, success.con.ag2, success.con.ag3) %>% 
  select(!c(df))

```

### LLM of force data

```{r eval=FALSE, echo=FALSE}

# once for all trials accepted the offer

data.pmfor.glmm <-                          
  df        %>%                  
  dplyr::filter(Choice == 1)           %>%            # removes rejected offers
  mutate(Effort.r = scale(Effort.raw)) %>% 
  mutate(Reward = scale(Reward.r))
figname <- 'only_accepted'

### try model with all possible interactions between effort, reward, agent and group (up to 4-way)

m.force.build.v1 <- buildmer(force_norm ~ Effort.r*Reward*Recipient_s2z*Group_vmpfc +
                                         (1 + Effort.r*Reward*Recipient_s2z | ID), data = data.pmfor.glmm,
                                       buildmerControl=list(crit='LRT', args=list(control=lmerControl(optimizer='bobyqa', optCtrl=list(maxfun=2e5)))))
save(m.force.build.v1, file = "output/model_force_build_v1.RData")

# rerun best model from above just in lmer so can e.g. standardise parameters below

m.force.v1 <- lmer(force_norm ~ Effort.r + Recipient_s2z + Reward + Group_vmpfc + Effort.r:Group_vmpfc + Effort.r:Recipient_s2z +
                               Recipient_s2z:Group_vmpfc +  Reward:Group_vmpfc + Effort.r:Reward + 
                               Effort.r:Reward:Group_vmpfc +  Effort.r:Recipient_s2z:Group_vmpfc + Recipient_s2z:Reward + 
                               Effort.r:Recipient_s2z:Reward + Recipient_s2z:Reward:Group_vmpfc + Effort.r:Recipient_s2z:Reward:Group_vmpfc + 
                               (1 + Effort.r + Recipient_s2z + Reward + Reward:Recipient_s2z | ID), data = data.pmfor.glmm,
                             control=lmerControl(optimizer='bobyqa', optCtrl=list(maxfun=2e5)))
save(m.force.v1, file = "output/model_force_v1.RData")

# and once only for successful trials

data.pmfor.glmm <-                          
  df        %>%                  
  dplyr::filter(Choice == 1, Success == 1)  %>%       # removes rejected offers and unsuccessful trials
  mutate(Effort.r = scale(Effort.raw))  %>% 
  mutate(Reward = scale(Reward.r))
figname <- 'only_accepted_successful'

### try model with all possible interactions between effort, reward, agent and group (up to 4-way)

m.force.build.v2 <- buildmer(force_norm ~ Effort.r*Reward*Recipient_s2z*Group_vmpfc +
                                         (1 + Effort*Reward*Recipient_s2z | ID), data = data.pmfor.glmm,
                                       buildmerControl=list(crit='LRT', args=list(control=lmerControl(optimizer='bobyqa', optCtrl=list(maxfun=2e5)))))
save(m.force.build.v2, file = "output/model_force_build_v2.RData")

# rerun best model from above just in lmer so can e.g. standardise parameters below

m.force.v2 <- lmer(force_norm ~ Effort.r + Group_vmpfc + Effort.r:Group_vmpfc +      Recipient_s2z + Reward + Effort.r:Reward + (1 + Effort +      Reward + Recipient_s2z | ID), data = data.pmfor.glmm,
                             control=lmerControl(optimizer='bobyqa', optCtrl=list(maxfun=2e5)))
save(m.force.v2, file = "output/model_force_v2.RData")

```

### Format results

```{r force-model-load, warning=FALSE, message=FALSE, echo=FALSE}

# Load models saved above

load("output/model_force_v1.RData")
load("output/model_force_v2.RData")

```

```{r force-model1-format, warning=FALSE, message=FALSE, echo=FALSE}

m.force1.best <- m.force.v1

# format and combine results

r.force1.full <- model_parameters(m.force1.best, standardize = "refit")
r.force1 <- r.force1.full %>%
  dplyr::filter(Effects == "fixed") %>%
  select(!c(df_error, Effects, Group, CI)) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Recipient_s2z1", replacement = "Recipient (Self vs. Other)")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Group_vmpfcHC", replacement = "Group (vmPFC vs. HC)")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Group_vmpfcLC", replacement = "Group (vmPFC vs. LC)")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Effort.r", replacement = "Effort")) %>%
  mutate(Parameter = str_replace_all(Parameter, pattern = ":", replacement = " * "))

```

```{r force-model2-format, echo = FALSE, cache = TRUE, warning=FALSE, message=FALSE}

m.force2.best <- m.force.v2

# format and combine results

r.force2.full <- model_parameters(m.force2.best, standardize = "refit") 
r.force2 <- r.force2.full %>%
  dplyr::filter(Effects == "fixed") %>%
  select(!c(df_error, Effects, Group, CI)) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Recipient_s2z1", replacement = "Recipient (Self vs. Other)")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Group_vmpfcHC", replacement = "Group (vmPFC vs. HC)")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Group_vmpfcLC", replacement = "Group (vmPFC vs. LC)")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = "Effort.r", replacement = "Effort")) %>%
  mutate(Parameter = str_replace_all(Parameter, pattern = ":", replacement = " * "))

```

### Post-hoc tests on force data

```{r force-posthocs, echo = FALSE, cache = TRUE, warning=FALSE, message=FALSE}

data.pmfor.glmm <-                          
  df        %>%                  
  dplyr::filter(Choice == 1)           %>%            # removes rejected offers
  mutate(Effort.r = scale(Effort.raw)) %>% 
  mutate(Reward = scale(Reward.r))

force.e <- data.pmfor.glmm                 %>%
  dplyr::group_by(PM_ID, Group, Recipient, Effort.f, Effort.raw)        %>%
  dplyr::summarise(mean_force = mean(force_norm, na.rm = T), .groups = "drop")

force.e.diff <- force.e %>% 
  pivot_wider(id_cols = c(PM_ID, Group, Effort.f, Effort.raw), names_from = Recipient, values_from = mean_force) %>% 
  mutate(diff = self - other) %>% 
  drop_na()

force.wilcox.2 <- wilcox.test(force.e.diff$self[force.e.diff$Group == "vmPFC" & force.e.diff$Effort.f == 2],
                    force.e.diff$other[force.e.diff$Group == "vmPFC" & force.e.diff$Effort.f == 2], paired = T)
force.wilcox.3 <- wilcox.test(force.e.diff$self[force.e.diff$Group == "vmPFC" & force.e.diff$Effort.f == 3],
                    force.e.diff$other[force.e.diff$Group == "vmPFC" & force.e.diff$Effort.f == 3], paired = T)
force.wilcox.4 <- wilcox.test(force.e.diff$self[force.e.diff$Group == "vmPFC" & force.e.diff$Effort.f == 4],
                    force.e.diff$other[force.e.diff$Group == "vmPFC" & force.e.diff$Effort.f == 4], paired = T)
force.wilcox.5 <- wilcox.test(force.e.diff$self[force.e.diff$Group == "vmPFC" & force.e.diff$Effort.f == 5],
                    force.e.diff$other[force.e.diff$Group == "vmPFC" & force.e.diff$Effort.f == 5], paired = T)
force.wilcox.6 <- wilcox.test(force.e.diff$self[force.e.diff$Group == "vmPFC" & force.e.diff$Effort.f == 6],
                    force.e.diff$other[force.e.diff$Group == "vmPFC" & force.e.diff$Effort.f == 6], paired = T)

force1.con.group <- contrast(emmeans(m.force1.best, ~ Group_vmpfc), 'pairwise', by=NULL, adjust = "none", type = "response")
force1.con.group <- as.data.frame(force1.con.group )%>%
  add_column(term = "Effect of group", .before = "contrast")

force1.con.ag <- contrast(emmeans(m.force1.best, ~ Recipient_s2z | Group_vmpfc), 'pairwise', by=NULL, adjust = "none", type = "response")
force1.con.ag <- as.data.frame(force1.con.ag)

# see below if error in this section

force1.con.ag1 <- force1.con.ag %>%
  subset(contrast == "self vmPFC - self HC" | contrast == "self vmPFC - self LC" | contrast == "self HC - self LC") %>%
  add_column(term = "Effect of group for self", .before = "contrast")

force1.con.ag2 <- force1.con.ag %>%
  subset(contrast == "other vmPFC - other HC" | contrast == "other vmPFC - other LC" | contrast == "other HC - other LC") %>%
  add_column(term = "Effect of group for other", .before = "contrast")

force1.con.ag3 <- force1.con.ag %>%
  subset(contrast == "self vmPFC - other vmPFC" | contrast == "self HC - other HC" | contrast == "self LC - other LC") %>%
  add_column(term = "Effect of recipient in each group", .before = "contrast")

## depending on package versions notation may use "-" instead of "/" in section above

# force1.con.ag1 <- force1.con.ag %>%
#   subset(contrast == "self vmPFC / self HC" | contrast == "self vmPFC / self LC" | contrast == "self HC / self LC") %>%
#   add_column(term = "Effect of group for self", .before = "contrast")
# 
# force1.con.ag2 <- force1.con.ag %>%
#   subset(contrast == "other vmPFC / other HC" | contrast == "other vmPFC / other LC" | contrast == "other HC / other LC") %>%
#   add_column(term = "Effect of group for other", .before = "contrast")
# 
# force1.con.ag3 <- force1.con.ag %>%
#   subset(contrast == "self vmPFC / other vmPFC" | contrast == "self HC / other HC" | contrast == "self LC / other LC") %>%
#   add_column(term = "Effect of recipient in each group", .before = "contrast")

force1.con.inter.ag <- contrast(contrast(emmeans(m.force1.best, ~ Recipient_s2z | Group_vmpfc), adjust = "none", 'pairwise'),
                                'pairwise', by=NULL, adjust = "none", type = "response")
force1.con.inter.ag <- as.data.frame(force1.con.inter.ag) %>%
  add_column(term = "Recipient*group interaction", .before = "contrast")

force1.con.inter.eg <- emtrends(m.force1.best, pairwise ~ Group_vmpfc, var = "Effort.r", adjust = "none", type = "response")

force1.con.eg <- as.data.frame(force1.con.inter.eg[["emtrends"]]) %>% 
  add_column(term = "Effect of effort in each group", .before = "Effort.r.trend")

force1.con.inter.eg <- as.data.frame(force1.con.inter.eg[["contrasts"]]) %>% 
  add_column(term = "Effort*group interaction", .before = "contrast")

force1.con.all <- bind_rows(force1.con.group, force1.con.ag1, force1.con.ag2, force1.con.ag3, force1.con.inter.ag, force1.con.inter.eg) %>%
  select(!c(df))

```

### Plot force data

```{r force-plots, echo=FALSE}

data.pmfor.glmm <-                          
  df        %>%                  
  dplyr::filter(Choice == 1)           %>%            # removes rejected offers
  mutate(Effort.r = scale(Effort.raw)) %>% 
  mutate(Reward = scale(Reward.r))

### plot the force data across effort levels

force.sig <- data.frame(Effort.f = c(5.4,5.1,5.4), mean_force = c(0.88, 0.85, 0.85), label = c("n.s.", "*", "n.s."),
                        Group = factor(group.lims, levels = group.lims), Recipient = "Self")

force.sig2 <- data.frame(Effort.f = c(1:5), mean_force = c(1,1,1,0.93,1,1,1,0.86,1,1), label = c("", "", "", "*", "", "", "", "*", "", "*"),
                        Group = factor(group.lims[1:2], levels = group.lims[1:2]), Recipient = factor(c(rep(agent.lims[1],5), rep(agent.lims[2],5))))

graphname <- paste0('plots/Effort_force.tiff')

if (saveplots == 1) {tiff(graphname, units="in", width = plotW*2, height = plotH, res = resolution)}

force.e.plt <- ggplot(force.e, aes(x = Effort.f, y = mean_force, group = Recipient, color = Recipient, fill = Recipient, linetype = Recipient)) +
  geom_jitter(position = position_jitterdodge(dodge.width = 0.5, jitter.height = 0, jitter.width = 0.2), size = 2, alpha = 0.2, show.legend = F) +
  geom_smooth(method = 'lm', alpha = 0, size = 1.5, formula = y ~ x) +
  scale_x_discrete(name = 'Effort level') + 
  scale_y_continuous(name = "Force exerted<br><span style='font-size:14pt'>(Normalised area under the curve)</span style'>") +
  scale_fill_manual(limits = agent.lims, values = agent.fills, labels = agent.labs) +
  scale_colour_manual(limits = agent.lims, values = agent.fills, labels = agent.labs) +
  scale_linetype_discrete(limits = agent.lims, labels = agent.labs) +
  theme_classic() +
  theme(legend.spacing.y = unit(0.1,"in"),
        legend.title = element_blank(),
        #legend.position = c(0.5,0.55),
        axis.text=element_text(size = axtext), 
        axis.title.x=element_text(size = axtitle),
        axis.title.y=element_markdown(size = axtitle),
        legend.text=element_text(size = axtitle), 
        strip.text = element_text(size = axtext)) +
  guides(linetype = guide_legend(override.aes = list(size = 2), byrow = TRUE), 
         fill = guide_legend(byrow = TRUE),
         color = guide_legend(byrow = TRUE)) +
  geom_text(aes(size = Group), data = force.sig, colour = 'black', label = c("n.s.", "*", "n.s.")) +
  geom_text(aes(size = Group), data = force.sig2, colour = 'black', label = c("", "", "", "*", "", "", "", "*", "", "*")) +
  scale_size_manual(values = c(5,7,5), guide = 'none') +
  facet_grid(cols = vars(Group), labeller = labeller(Group = group.labs.leg.lab)) 
  
if (saveplots == 1) {
  force.e.plt
  dev.off()}

### plot the force data across effort and reward levels

graphname <- paste0('plots/Effort_reward_agent_force.tiff')

if (saveplots == 1) {tiff(graphname, units="in", width = plotW*2, height = plotH, res = resolution)}

force.base.plt <- ggplot(data.pmfor.glmm, aes(x=Effort.f, y=force_norm, group = Recipient, color = Recipient, fill = Recipient, linetype = Recipient)) +
  geom_smooth(method = 'lm', alpha = 0.5, size = 0.4, formula = y ~ x, show.legend = FALSE) + 
  geom_smooth(method = 'lm', alpha = 0, size = 0.4, formula = y ~ x) + 
  scale_x_discrete(name = 'Effort level') + 
  scale_y_continuous(name = "Force exerted (normalised AUC)") +
  scale_fill_manual(limits = agent.lims, values = agent.fills, guide = 'none') +
  scale_colour_manual(limits = agent.lims, values = agent.fills, labels = agent.labs) +
  scale_linetype_discrete(limits = agent.lims, labels = agent.labs) +
  theme_classic() +
  theme(legend.title = element_blank(),
        axis.text.x=element_text(size = axtext), 
        axis.text.y=element_text(size = axtext-4), 
        strip.text=element_text(size = axtext), 
        axis.title=element_text(size = axtitle),
        legend.text=element_text(size = axtitle)) +
  guides(linetype = guide_legend(override.aes = list(size = 2))) 

force.er.plt <- force.base.plt +
  facet_grid(cols = vars(Group), rows = vars(Reward.f), labeller = labeller(Group = group.labs.leg.lab, Reward.f = reward.labs))

if (saveplots == 1) {
  force.er.plt
  dev.off()}

```

## Lesion mapping

```{r lesion-map, echo = FALSE, cache = TRUE, warning=FALSE, message=FALSE}

# extract behavioural variables for lesion mapping - receipient effect on ks and choices

df.map <- read_csv("data/lesion_size.csv", show_col_types = FALSE)

df.map <- df.map %>% 
  add_column("PM_ID" = factor(df.map$ID), .before = "ID") 

m.gam.log.all <- glmer(k ~ Recipient_s2z + (1 + Recipient_s2z | ID), data = df.2kl.full, family = Gamma(link = 'log'), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))

k.ranids <- levels(m.gam.log.all@frame[["ID"]])
k.ranef <- ranef(m.gam.log.all)[["ID"]] %>% 
  add_column("PM_ID" = k.ranids, .before = 1)
colnames(k.ranef) <- paste(colnames(k.ranef), "k", sep = "_")

# m.choice.all <- glmer(Choice ~ Effort + Reward + Recipient_s2z +
#                             (1 + Effort + Reward + Recipient_s2z | PM_ID), data = df.full, family = "binomial",
#                       control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# save(m.choice.all, file = "output/model_choice_all_inc_OL.RData")
load("output/model_choice_all_inc_OL.RData")

choice.ranef <- ranef(m.choice.all)[["PM_ID"]]
choice.ranids <- levels(m.choice.all@frame[["PM_ID"]])
choice.ranef$PM_ID <- choice.ranids
colnames(choice.ranef) <- paste(colnames(choice.ranef), "choice", sep = "_")
choice.ranef$PM_ID_choice[choice.ranef$PM_ID == 507] <- 270

df.map.wide <- left_join(k.ranef %>% select(!contains("Intercept")) %>% rename(PM_ID = "PM_ID_k"), 
                         df.2k.full %>% select(!contains(c("DB", "-"))) %>% select("ID", "Group_vmpfc", contains(c("choice", "_k"))) %>% rename(PM_ID = ID), by = "PM_ID")

df.map.wide <- left_join(df.map.wide, df.map %>% select(!"ID"), by = "PM_ID")
df.map.wide$lesion[is.na(df.map.wide$lesion)] <- 0

df.map.wide <- left_join(df.map.wide, choice.ranef %>% select(!contains("Intercept")) %>% rename(PM_ID = "PM_ID_choice"), by = "PM_ID")

if (savecsvs == 1) {write.csv(df.map.wide, "data/behavioural_parameters_all.csv", row.names = F, na = "")}

# RUN LESION MAPPING
# using above csv
# then extract the number of voxels / volume of damage for each patient in the regions identified in lesion mapping

df.k.roi <- read_csv("data/all_patients_Recipient_k_negative.csv", show_col_types = FALSE)

df.k.roi <- df.k.roi %>% 
  add_column("PM_ID" = factor(df.map$ID), .before = "ID") 

df.choice.roi <- read_csv("data/all_patients_Recipient_choice_positive.csv", show_col_types = FALSE)

df.choice.roi <- df.choice.roi %>% 
  add_column("PM_ID" = factor(df.map$ID), .before = "ID")

df.map.patients <- left_join(df.map.wide %>% subset(Group_vmpfc != "HC"), 
                             df.k.roi %>% select(!"ID"), by = "PM_ID")

df.map.patients <- left_join(df.map.patients, 
                             df.choice.roi %>% select(!"ID"), by = "PM_ID")

df.map.patients <- df.map.patients %>% 
  add_column("other_self_choice" = df.map.patients$PM_other_choice - df.map.patients$PM_self_choice) %>% 
  add_column("other_self_k" = df.map.patients$PM_other_k - df.map.patients$PM_self_k) %>% 
  add_column("choice_effect_rank" = rank(-df.map.patients$Recipient_s2z1_choice, ties.method = "average")) %>% 
  add_column("effort_effect_rank" = rank(df.map.patients$Effort_choice, ties.method = "average")) %>% 
  add_column("reward_effect_rank" = rank(df.map.patients$Reward_choice, ties.method = "average")) %>% 
  add_column("k_effect_rank" = rank(-df.map.patients$Recipient_s2z1_k, ties.method = "average"))

```

### Plot lesion size correlations (all patients)

```{r lesion-sizes-plot, warning=FALSE, message=FALSE, echo = FALSE, fig.height=6, fig.width=8}

cor.size.Achoice <- cor.test(df.map.patients$lesion, df.map.patients$choice_effect_rank)

plot.size.Achoice <- ggplot(df.map.patients, aes(x = lesion, y = choice_effect_rank)) + 
  geom_point(aes(color = Group_vmpfc, shape = Group_vmpfc), size = 6, alpha = 0.5) + 
  geom_smooth(colour = 'black', method = 'lm', alpha = 0.3, size = 0.75, show.legend = FALSE) + 
  geom_smooth(colour = 'black', method = 'lm', alpha = 0, size = 2) +
  scale_x_continuous(name = "Total lesion volume (mm<sup>3</sup>)") +
  scale_y_continuous(name = "Other vs. self effect<br>on choices (rank)") +
  scale_color_manual(limits = group.lims.ol, values = group.fills.ol, labels = group.labs.leg.ol) +
  scale_shape_discrete(limits = group.lims.ol, labels = group.labs.leg.ol) +
  theme_classic() + 
  theme(legend.title = element_blank(),
        legend.text = element_markdown(size = axtitle),
        axis.text = element_markdown(size = axtext),
        axis.title.x = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle)) +
  guides(shape = guide_legend(override.aes = list(size = 6))) +
  annotate(geom='richtext', 
           x = 6000, y = 40,
           label = paste0("_r_","<sub>(", (sum(!is.na(df.map.patients$lesion))-2),")</sub>=", 
                          format(round(cor.size.Achoice[["estimate"]][["cor"]],digits=2), nsmall=2),", _p_", 
                          pvalrf(cor.size.Achoice[["p.value"]])),
           fill = NA, label.color = NA, size = 6)

# print(plot.size.Achoice)

plot.size.Achoice <- plot.size.Achoice + theme(legend.position = "none")

cor.size.Rk <- cor.test(df.map.patients$lesion, df.map.patients$k_effect_rank)

plot.size.Rk <- ggplot(df.map.patients, aes(x = lesion, y = k_effect_rank)) + 
  geom_point(aes(color = Group_vmpfc, shape = Group_vmpfc), size = 6, alpha = 0.5) + 
  geom_smooth(colour = 'black', method = 'lm', alpha = 0.3, size = 0.75, show.legend = FALSE) + 
  geom_smooth(colour = 'black', method = 'lm', alpha = 0, size = 2) +
  scale_x_continuous(name = "Total lesion volume (mm<sup>3</sup>)", position = "top") +
  scale_y_continuous(name = paste0("Other vs. self effect<br>on *\u039A* values (rank)"), trans = "reverse") +
  scale_color_manual(limits = group.lims.ol, values = group.fills.ol, labels = group.labs.leg.ol) +
  scale_shape_discrete(limits = group.lims.ol, labels = group.labs.leg.ol) +
  theme_classic() + 
  theme(legend.title = element_blank(),
        legend.text = element_markdown(size = axtitle),
        axis.text = element_markdown(size = axtext),
        axis.title.x.top = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle)) +
  guides(shape = guide_legend(override.aes = list(size = 6))) +
  annotate(geom='richtext', 
           x = 6000, y = 40,
           label = paste0("_r_","<sub>(", (sum(!is.na(df.map.patients$lesion))-2),")</sub>=", 
                          format(round(cor.size.Rk[["estimate"]][["cor"]],digits=2), nsmall=2),", _p_", 
                          pvalrf(cor.size.Rk[["p.value"]])),
           fill = NA, label.color = NA, size = 6)

# print(plot.size.Rk)

plot.size.Rk <- plot.size.Rk + theme(legend.position = "none")

cor.size.Echoice <- cor.test(df.map.patients$lesion, df.map.patients$effort_effect_rank)

plot.size.Echoice <- ggplot(df.map.patients, aes(x = lesion, y = effort_effect_rank)) + 
  geom_point(aes(color = Group_vmpfc, shape = Group_vmpfc), size = 6, alpha = 0.5) + 
  geom_smooth(colour = 'black', method = 'lm', alpha = 0.3, size = 0.75, show.legend = FALSE) + 
  geom_smooth(colour = 'black', method = 'lm', alpha = 0, size = 2) +
  scale_x_continuous(name = "Total lesion volume (mm<sup>3</sup>)") +
  scale_y_continuous(name = "Effort effect<br>on choices (rank)") +
  scale_color_manual(limits = group.lims.ol, values = group.fills.ol, labels = group.labs.leg.ol) +
  scale_shape_discrete(limits = group.lims.ol, labels = group.labs.leg.ol) +
  theme_classic() + 
  theme(legend.title = element_blank(),
        legend.text = element_markdown(size = axtitle),
        axis.text = element_markdown(size = axtext),
        axis.title.x = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle)) +
  guides(shape = guide_legend(override.aes = list(size = 6))) +
  annotate(geom='richtext', 
           x = 6000, y = 40,
           label = paste0("_r_","<sub>(", (sum(!is.na(df.map.patients$lesion))-2),")</sub>=", 
                          format(round(cor.size.Echoice[["estimate"]][["cor"]],digits=2), nsmall=2),", _p_", 
                          pvalrf(cor.size.Echoice[["p.value"]])),
           fill = NA, label.color = NA, size = 6)

# print(plot.size.Echoice)

plot.size.Echoice <- plot.size.Echoice + theme(legend.position = "none")

cor.size.Rchoice <- cor.test(df.map.patients$lesion, df.map.patients$reward_effect_rank)

plot.size.Rchoice <- ggplot(df.map.patients, aes(x = lesion, y = reward_effect_rank)) + 
  geom_point(aes(color = Group_vmpfc, shape = Group_vmpfc), size = 6, alpha = 0.5) + 
  geom_smooth(colour = 'black', method = 'lm', alpha = 0.3, size = 0.75, show.legend = FALSE) + 
  geom_smooth(colour = 'black', method = 'lm', alpha = 0, size = 2) +
  scale_x_continuous(name = "Total lesion volume (mm<sup>3</sup>)") +
  scale_y_continuous(name = "Reward effect<br>on choices (rank)") +
  scale_color_manual(limits = group.lims.ol, values = group.fills.ol, labels = group.labs.leg.ol) +
  scale_shape_discrete(limits = group.lims.ol, labels = group.labs.leg.ol) +
  theme_classic() + 
  theme(legend.title = element_blank(),
        legend.text = element_markdown(size = axtitle),
        axis.text = element_markdown(size = axtext),
        axis.title.x = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle)) +
  guides(shape = guide_legend(override.aes = list(size = 6))) +
  annotate(geom='richtext', 
           x = 6000, y = 40,
           label = paste0("_r_","<sub>(", (sum(!is.na(df.map.patients$lesion))-2),")</sub>=", 
                          format(round(cor.size.Rchoice[["estimate"]][["cor"]],digits=2), nsmall=2),", _p_", 
                          pvalrf(cor.size.Rchoice[["p.value"]])),
           fill = NA, label.color = NA, size = 6)

# print(plot.size.Rchoice)

lesion.size.leg <- get_legend(plot.size.Rchoice)

plot.size.Rchoice <- plot.size.Rchoice + theme(legend.position = "none")

```

### Plot lesion mapping - all patients

```{r map-all-plot, warning=FALSE, message=FALSE, echo = FALSE, fig.height=6, fig.width=4}

# Binary, not ranked

df.map.patients$choice_vox_bin <- factor(df.map.patients$choice_voxels > 0, levels = c("FALSE", "TRUE"), labels = c("No damage", "Damage"))

hc.choice.diff.av <- mean(df.2k.full$PM_other_choice[df.2k.full$Group == "HC"] - df.2k.full$PM_self_choice[df.2k.full$Group == "HC"])

plot.all.choiceV.Achoice.raw <- ggplot(df.map.patients, aes(x = choice_vox_bin, y = -1 * Recipient_s2z1_choice, fill = choice_vox_bin, colour = choice_vox_bin)) + 
  stat_summary(fun.data = "mean_cl_boot", geom = "errorbar", conf.int=.95, position=position_dodge(0.75), width = 0, alpha = 1) +
  stat_summary(fun = mean, position=position_dodge(0.75), width = 0.75, color = '#e67b4c', size = 3) +
  geom_jitter(position = position_jitterdodge(dodge.width = 0.75, jitter.height = 0, jitter.width = 0.3), size = 3, show.legend = FALSE, alpha = 0.5, fill = '#e67b4c') +
  scale_x_discrete(name = "Area 14m & 32") +
  scale_y_continuous(name = "Other vs. self choice difference<br><span style='font-size:14pt'>(arbitrary units)</span style'>") +
  scale_colour_manual(values = c('#f5b093', '#f5b093')) +
  scale_fill_manual(values = c('#db5a21', '#db5a21')) +
  theme_classic() + 
  theme(legend.title = element_blank(),
        legend.text = element_markdown(size = axtitle),
        axis.text = element_markdown(size = axtext),
        axis.title.x = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle),
        legend.position = "none") +
  guides(shape = guide_legend(override.aes = list(size = 6))) 

# print(plot.all.choiceV.Achoice.raw)

# Binary, ranked

plot.all.choiceV.Achoice <- ggplot(df.map.patients, aes(x = choice_vox_bin, y = choice_effect_rank, fill = choice_vox_bin, colour = choice_vox_bin)) + 
  stat_summary(fun.data = "mean_cl_boot", geom = "errorbar", conf.int=.95, position=position_dodge(0.75), width = 0, alpha = 1) +
  stat_summary(fun = mean, position=position_dodge(0.75), width = 0.75, color = '#e67b4c', size = 3) +
  geom_jitter(position = position_jitterdodge(dodge.width = 0.75, jitter.height = 0, jitter.width = 0.3), size = 3, show.legend = FALSE, alpha = 0.5, fill = '#e67b4c') +
  scale_x_discrete(name = "Area 14m & 32") +
  scale_y_continuous(name = "Other vs. self choice difference (rank)") +
  scale_colour_manual(values = c('#f5b093', '#f5b093')) +
  scale_fill_manual(values = c('#db5a21', '#db5a21')) +
  theme_classic() + 
  theme(legend.title = element_blank(),
        legend.text = element_markdown(size = axtitle),
        axis.text = element_markdown(size = axtext),
        axis.title.x = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle),
        legend.position = "none") +
  guides(shape = guide_legend(override.aes = list(size = 6))) 

# print(plot.all.choiceV.Achoice)

# Binary, not ranked

df.map.patients$k_vox_bin <- factor(df.map.patients$k_voxels > 0, levels = c("FALSE", "TRUE"), labels = c("No damage", "Damage"))

hc.k.diff.av <- mean(df.2k.full$`other-self_k`[df.2k.full$Group == "HC"])

plot.all.kV.Rk.raw <- ggplot(df.map.patients, aes(x = k_vox_bin, y = -1 * Recipient_s2z1_k, fill = k_vox_bin, colour = k_vox_bin)) + 
  stat_summary(fun.data = "mean_cl_boot", geom = "errorbar", conf.int=.95, position=position_dodge(0.75), width = 0, alpha = 1) +
  stat_summary(fun = mean, position=position_dodge(0.75), width = 0.75, color = '#890000', size = 3) +
  geom_jitter(position = position_jitterdodge(dodge.width = 0.75, jitter.height = 0, jitter.width = 0.3), size = 3, show.legend = FALSE, alpha = 0.5, fill = '#C87E80') +
  scale_x_discrete(name = "Area 14m & sgACC", position = "top") +
  scale_y_continuous(name = paste0("Other vs. self *\u039A* difference<br><span style='font-size:14pt'>(arbitrary units)</span style'>"), trans = "reverse") +
  scale_colour_manual(values = c('#C87E80', '#C87E80')) +
  scale_fill_manual(values = c('#890000', '#890000')) +
  theme_classic() + 
  theme(legend.title = element_blank(),
        legend.text = element_markdown(size = axtitle),
        axis.text = element_markdown(size = axtext),
        axis.title.x.top = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle),
        legend.position = "none") +
  guides(shape = guide_legend(override.aes = list(size = 6)))

# print(plot.all.kV.Rk.raw)

# Binary, ranked

plot.all.kV.Rk <- ggplot(df.map.patients, aes(x = k_vox_bin, y = k_effect_rank, fill = k_vox_bin, colour = k_vox_bin)) + 
  stat_summary(fun.data = "mean_cl_boot", geom = "errorbar", conf.int=.95, position=position_dodge(0.75), width = 0, alpha = 1) +
  stat_summary(fun = mean, position=position_dodge(0.75), width = 0.75, color = '#890000', size = 3) +
  geom_jitter(position = position_jitterdodge(dodge.width = 0.75, jitter.height = 0, jitter.width = 0.3), size = 3, show.legend = FALSE, alpha = 0.5, fill = '#C87E80') +
  scale_x_discrete(name = "Area 14m & sgACC", position = "top") +
  scale_y_continuous(name = paste0("Other vs. self *\u039A* difference (rank)"), trans = "reverse") +
  scale_colour_manual(values = c('#C87E80', '#C87E80')) +
  scale_fill_manual(values = c('#890000', '#890000')) +
  theme_classic() + 
  theme(legend.title = element_blank(),
        legend.text = element_markdown(size = axtitle),
        axis.text = element_markdown(size = axtext),
        axis.title.x.top = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle),
        legend.position = "none") +
  guides(shape = guide_legend(override.aes = list(size = 6)))

# print(plot.all.kV.Rk)

# Binary, not ranked, HC line

hc.choice.self.av <- mean(df.2k.full$PM_self_choice[df.2k.full$Group == "HC"])

plot.all.choiceV.Schoice <- ggplot(df.map.patients, aes(x = choice_vox_bin, y = PM_self_choice, fill = choice_vox_bin, colour = choice_vox_bin)) + 
  geom_hline(yintercept = hc.choice.self.av, linetype = 'dotted', col = 'grey') +
  stat_summary(fun.data = "mean_cl_boot", geom = "errorbar", conf.int=.95, position=position_dodge(0.75), width = 0, alpha = 1) +
  stat_summary(fun = mean, position=position_dodge(0.75), width = 0.75, color = agent.fills[1], size = 3) +
  geom_jitter(position = position_jitterdodge(dodge.width = 0.75, jitter.height = 0, jitter.width = 0.3), size = 3, show.legend = FALSE, alpha = 0.5, fill = agent.fills[1]) +
  scale_x_discrete(name = "Area 14m & 32") +
  scale_y_continuous(name = "Proportion accept for self") +
  scale_color_manual(values = c(agent.colours[1],agent.colours[1])) +
  scale_fill_manual(values = c(agent.fills[1],agent.fills[1])) +
  theme_classic() + 
  theme(legend.title = element_blank(),
        legend.text = element_markdown(size = axtitle),
        axis.text = element_markdown(size = axtext),
        axis.title.x = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle),
        legend.position = "none") +
  guides(shape = guide_legend(override.aes = list(size = 6))) 

# print(plot.all.choiceV.Schoice)

hc.choice.other.av <- mean(df.2k.full$PM_other_choice[df.2k.full$Group == "HC"])

plot.all.choiceV.Ochoice <- ggplot(df.map.patients, aes(x = choice_vox_bin, y = PM_other_choice, fill = choice_vox_bin, colour = choice_vox_bin)) + 
  geom_hline(yintercept = hc.choice.other.av, linetype = 'dotted', col = 'grey') +
  stat_summary(fun.data = "mean_cl_boot", geom = "errorbar", conf.int=.95, position=position_dodge(0.75), width = 0, alpha = 1) +
  stat_summary(fun = mean, position=position_dodge(0.75), width = 0.75, color = agent.fills[2], size = 3) +
  geom_jitter(position = position_jitterdodge(dodge.width = 0.75, jitter.height = 0, jitter.width = 0.3), size = 3, show.legend = FALSE, alpha = 0.5, fill = agent.fills[2]) +
  scale_x_discrete(name = "Area 14m & 32") +
  scale_y_continuous(name = "Proportion accept for other") +
  scale_color_manual(values = c(agent.colours[2],agent.colours[2])) +
  scale_fill_manual(values = c(agent.fills[2],agent.fills[2])) +
  theme_classic() + 
  theme(legend.title = element_blank(),
        legend.text = element_markdown(size = axtitle),
        axis.text = element_markdown(size = axtext),
        axis.title.x = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle),
        legend.position = "none") +
  guides(shape = guide_legend(override.aes = list(size = 6))) 

# print(plot.all.choiceV.Ochoice) 

hc.k.self.av <- mean(df.2k.full$PM_self_k[df.2k.full$Group == "HC"])

plot.all.kV.Sk <- ggplot(df.map.patients, aes(x = k_vox_bin, y = PM_self_k, fill = k_vox_bin, colour = k_vox_bin)) + 
  geom_hline(yintercept = hc.k.self.av, linetype = 'dotted', col = 'grey') +
  stat_summary(fun.data = "mean_cl_boot", geom = "errorbar", conf.int=.95, position=position_dodge(0.75), width = 0, alpha = 1) +
  stat_summary(fun = mean, position=position_dodge(0.75), width = 0.75, color = agent.fills[1], size = 3) +
  geom_jitter(position = position_jitterdodge(dodge.width = 0.75, jitter.height = 0, jitter.width = 0.3), size = 3, show.legend = FALSE, alpha = 0.5, fill = agent.fills[1]) +
  scale_x_discrete(name = "Area 14m & sgACC", position = "top") +
  scale_y_continuous(name = paste0("Self *\u039A*"), trans = "reverse") +
  scale_color_manual(values = c(agent.colours[1],agent.colours[1])) +
  scale_fill_manual(values = c(agent.fills[1],agent.fills[1])) +
  theme_classic() + 
  theme(legend.title = element_blank(),
        legend.text = element_markdown(size = axtitle),
        axis.text = element_markdown(size = axtext),
        axis.title.x.top = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle),
        legend.position = "none") +
  guides(shape = guide_legend(override.aes = list(size = 6)))

# print(plot.all.kV.Sk)

hc.k.other.av <- mean(df.2k.full$PM_other_k[df.2k.full$Group == "HC"])

plot.all.kV.Ok <- ggplot(df.map.patients, aes(x = k_vox_bin, y = PM_other_k, fill = k_vox_bin, colour = k_vox_bin)) + 
  geom_hline(yintercept = hc.k.other.av, linetype = 'dotted', col = 'grey') +
  stat_summary(fun.data = "mean_cl_boot", geom = "errorbar", conf.int=.95, position=position_dodge(0.75), width = 0, alpha = 1) +
  stat_summary(fun = mean, position=position_dodge(0.75), width = 0.75, color = agent.fills[2], size = 3) +
  geom_jitter(position = position_jitterdodge(dodge.width = 0.75, jitter.height = 0, jitter.width = 0.3), size = 3, show.legend = FALSE, alpha = 0.5, fill = agent.fills[1]) +
  scale_x_discrete(name = "Area 14m & sgACC", position = "top") +
  scale_y_continuous(name = paste0("Other *\u039A*"), trans = "reverse") +
  scale_color_manual(values = c(agent.colours[2],agent.colours[2])) +
  scale_fill_manual(values = c(agent.fills[2],agent.fills[2])) +
  theme_classic() + 
  theme(legend.title = element_blank(),
        legend.text = element_markdown(size = axtitle),
        axis.text = element_markdown(size = axtext),
        axis.title.x.top = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle),
        legend.position = "none") +
  guides(shape = guide_legend(override.aes = list(size = 6)))

choiceV.lab <- ggplot() +
  geom_textbox(mapping = aes(0.85, 0.25,
                             label = "<span style='font-size:14pt'>← <i>Less prosocial</i><span>", text.color = "black", orientation = "left-rotated",
                             box.color = "transparent", hjust = 0, vjust = 0.5, halign = 0), width = unit(0.47, "npc")) +
  geom_textbox(mapping = aes(0.85, 0.85,
                             label = "<span style='font-size:14pt'><i>More prosocial</i> →<span>", text.color = "black", orientation = "left-rotated",
                             box.color = "transparent", hjust = 0.9, vjust = 0.5, halign = 1), width = unit(0.47, "npc")) +
  xlim(0, 1) +
  theme_classic() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.x = element_blank(),
        axis.line.x = element_blank(),
        axis.title.y = element_blank(),
        axis.line.y = element_blank())

kV.lab <- ggplot() +
  geom_textbox(mapping = aes(0.85, 0.25,
                             label = "<span style='font-size:14pt'>← <i>Less prosocial</i><span>", text.color = "black", orientation = "left-rotated",
                             box.color = "transparent", hjust = 0, vjust = 0.5, halign = 0), width = unit(0.47, "npc")) +
  geom_textbox(mapping = aes(0.85, 0.85,
                             label = "<span style='font-size:14pt'><i>More prosocial</i> →<span>", text.color = "black", orientation = "left-rotated",
                             box.color = "transparent", hjust = 0.9, vjust = 0.5, halign = 1), width = unit(0.47, "npc")) +
  xlim(0, 1) +
  theme_classic() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.x = element_blank(),
        axis.line.x = element_blank(),
        axis.title.y = element_blank(),
        axis.line.y = element_blank())

```

### Plot lesion mapping - vmpfc only

```{r map-vmpfc-plot, warning=FALSE, message=FALSE, echo = FALSE, fig.height=6, fig.width=4}

df.k.roi <- read_csv("data/vmPFC_only_Recipient_k_positive.csv", show_col_types = FALSE)

df.k.roi <- df.k.roi %>% 
  add_column("PM_ID" = factor(df.map$ID), .before = "ID") 

df.choice.roi <- read_csv("data/vmPFC_only_Recipient_choice_negative.csv", show_col_types = FALSE)

df.choice.roi <- df.choice.roi %>% 
  add_column("PM_ID" = factor(df.map$ID), .before = "ID")

df.map.patients <- left_join(df.map.wide %>% subset(Group_vmpfc != "HC"), 
                             df.k.roi %>% select(!"ID"), by = "PM_ID")

df.map.patients <- left_join(df.map.patients, 
                             df.choice.roi %>% select(!"ID"), by = "PM_ID")

df.map.patients <- df.map.patients %>% 
  subset(Group_vmpfc == "vmPFC")

df.map.patients <- df.map.patients %>% 
  add_column("choice_effect_rank" = rank(-df.map.patients$Recipient_s2z1_choice, ties.method = "average")) %>% 
  add_column("k_effect_rank" = rank(-df.map.patients$Recipient_s2z1_k, ties.method = "average")) 

# Binary, not ranked

df.map.patients$choice_vox_bin <- factor(df.map.patients$choice_voxels > 0, levels = c("FALSE", "TRUE"), labels = c("No damage", "Damage"))

plot.vmpfc.choiceV.Achoice.raw <- ggplot(df.map.patients, aes(x = choice_vox_bin, y = -1 * Recipient_s2z1_choice, fill = choice_vox_bin, colour = choice_vox_bin)) + 
  stat_summary(fun.data = "mean_cl_boot", geom = "errorbar", conf.int=.95, position=position_dodge(0.75), width = 0, alpha = 1) +
  stat_summary(fun = mean, position=position_dodge(0.75), width = 0.75, color = '#020085', size = 3) +
  geom_jitter(position = position_jitterdodge(dodge.width = 0.75, jitter.height = 0, jitter.width = 0.3), size = 3, show.legend = FALSE, alpha = 0.5, fill = '#7F8BC4') +
  scale_x_discrete(name = "Area 13a/b damage") +
  scale_y_continuous(name = "Other vs. self choice difference<br><span style='font-size:14pt'>(arbitrary units)</span style'>") +
  scale_colour_manual(values = c('#7F8BC4', '#7F8BC4')) +
  scale_fill_manual(values = c('#BFC5E2', '#BFC5E2')) +
  theme_classic() + 
  theme(legend.title = element_blank(),
        legend.text = element_markdown(size = axtitle),
        axis.text = element_markdown(size = axtext),
        axis.title.x = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle),
        legend.position = "none") +
  guides(shape = guide_legend(override.aes = list(size = 6))) 

# print(plot.vmpfc.choiceV.Achoice.raw)

plot.vmpfc.choiceV.Achoice.raw <- plot.vmpfc.choiceV.Achoice.raw + theme(legend.position = "none")

df.map.patients$k_vox_bin <- factor(df.map.patients$k_voxels > 0, levels = c("FALSE", "TRUE"), labels = c("No damage", "Damage"))

plot.vmpfc.kV.Rk.raw <- ggplot(df.map.patients, aes(x = k_vox_bin, y = -1 * Recipient_s2z1_k, fill = k_vox_bin, colour = k_vox_bin)) + 
  stat_summary(fun.data = "mean_cl_boot", geom = "errorbar", conf.int=.95, position=position_dodge(0.75), width = 0, alpha = 1) +
  stat_summary(fun = mean, position=position_dodge(0.75), width = 0.75, color = '#009087', size = 3) +
  geom_jitter(position = position_jitterdodge(dodge.width = 0.75, jitter.height = 0, jitter.width = 0.3), size = 3, show.legend = FALSE, alpha = 0.5, fill = '#94C9C4') +
  scale_x_discrete(name = "Area 13a/b damage", position = "top") +
  scale_y_continuous(name = "Other vs. self k difference<br><span style='font-size:14pt'>(arbitrary units)</span style'>", trans = "reverse") +
  scale_colour_manual(values = c('#94C9C4', '#94C9C4')) +
  scale_fill_manual(values = c('#009087', '#009087')) +
  theme_classic() + 
  theme(legend.title = element_blank(),
        legend.text = element_markdown(size = axtitle),
        axis.text = element_markdown(size = axtext),
        axis.title.x = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle),
        legend.position = "none") +
  guides(shape = guide_legend(override.aes = list(size = 6))) 

# print(plot.vmpfc.kV.Rk.raw)

plot.vmpfc.kV.Rk.raw <- plot.vmpfc.kV.Rk.raw + theme(legend.position = "none")

# Binary, ranked

df.map.patients$choice_vox_bin <- factor(df.map.patients$choice_voxels > 0, levels = c("FALSE", "TRUE"), labels = c("No damage", "Damage"))

plot.vmpfc.choiceV.Achoice <- ggplot(df.map.patients, aes(x = choice_vox_bin, y = choice_effect_rank, fill = choice_vox_bin, colour = choice_vox_bin)) + 
  stat_summary(fun.data = "mean_cl_boot", geom = "errorbar", conf.int=.95, position=position_dodge(0.75), width = 0, alpha = 1) +
  stat_summary(fun = mean, position=position_dodge(0.75), width = 0.75, color = '#020085', size = 3) +
  geom_jitter(position = position_jitterdodge(dodge.width = 0.75, jitter.height = 0, jitter.width = 0.3), size = 3, show.legend = FALSE, alpha = 0.5, fill = '#7F8BC4') +
  scale_x_discrete(name = "Area 13a/b damage") +
  scale_y_continuous(name = "Other vs. self choice difference (rank)") +
  scale_colour_manual(values = c('#7F8BC4', '#7F8BC4')) +
  scale_fill_manual(values = c('#BFC5E2', '#BFC5E2')) +
  theme_classic() + 
  theme(legend.title = element_blank(),
        legend.text = element_markdown(size = axtitle),
        axis.text = element_markdown(size = axtext),
        axis.title.x = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle)) +
  guides(shape = guide_legend(override.aes = list(size = 6))) 

# print(plot.vmpfc.choiceV.Achoice)

plot.vmpfc.choiceV.Achoice <- plot.vmpfc.choiceV.Achoice + theme(legend.position = "none")

df.map.patients$k_vox_bin <- factor(df.map.patients$k_voxels > 0, levels = c("FALSE", "TRUE"), labels = c("No damage", "Damage"))

plot.vmpfc.kV.Rk <- ggplot(df.map.patients, aes(x = k_vox_bin, y = k_effect_rank, fill = k_vox_bin, colour = k_vox_bin)) + 
  stat_summary(fun.data = "mean_cl_boot", geom = "errorbar", conf.int=.95, position=position_dodge(0.75), width = 0, alpha = 1) +
  stat_summary(fun = mean, position=position_dodge(0.75), width = 0.75, color = '#009087', size = 3) +
  geom_jitter(position = position_jitterdodge(dodge.width = 0.75, jitter.height = 0, jitter.width = 0.3), size = 3, show.legend = FALSE, alpha = 0.5, fill = '#94C9C4') +
  scale_x_discrete(name = "Area 13a/b damage", position = "top") +
  scale_y_continuous(name = "Other vs. self k difference (rank)", trans = "reverse") +
  scale_colour_manual(values = c('#94C9C4', '#94C9C4')) +
  scale_fill_manual(values = c('#009087', '#009087')) +
  theme_classic() + 
  theme(legend.title = element_blank(),
        legend.text = element_markdown(size = axtitle),
        axis.text = element_markdown(size = axtext),
        axis.title.x = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle),
        legend.position = "none") +
  guides(shape = guide_legend(override.aes = list(size = 6))) 

# print(plot.vmpfc.kV.Rk)

plot.vmpfc.kV.Rk <- plot.vmpfc.kV.Rk + theme(legend.position = "none")

hc.k.self.av <- mean(df.2k.full$PM_self_k[df.2k.full$Group == "HC"])
hc.k.self.rank <- rank(c(hc.k.self.av, df.map.patients$PM_self_k), ties.method = "average")[1] - 0.5

hc.k.other.av <- mean(df.2k.full$PM_other_k[df.2k.full$Group == "HC"])
hc.k.other.rank <- rank(c(hc.k.other.av, df.map.patients$PM_other_k), ties.method = "average")[1] - 0.5

# Binary, dots, with HC line

plot.vmpfc.kV.Sk <- ggplot(df.map.patients, aes(x = k_vox_bin, y = PM_self_k, colour = k_vox_bin, fill = k_vox_bin)) + 
  geom_hline(yintercept = hc.k.self.av, linetype = 'dotted', col = 'grey') +

  stat_summary(fun.data = "mean_cl_boot", geom = "errorbar", conf.int=.95, position=position_dodge(0.75), width = 0, alpha = 1) +
  stat_summary(fun = mean, position=position_dodge(0.75), width = 0.75, color = agent.fills[1], size = 3) +
  geom_jitter(position = position_jitterdodge(dodge.width = 0.75, jitter.height = 0, jitter.width = 0.3), size = 3, show.legend = FALSE, alpha = 0.5) + 
  scale_x_discrete(name = paste0("Area 13a/b damage"), position = "top") +
  scale_y_continuous(name = paste0('*\u039A*<sub>self</sub>'), trans = "reverse") +
  scale_color_manual(values = c(agent.colours[1],agent.colours[1])) +
  scale_fill_manual(values = c(agent.fills[1],agent.fills[1])) +
  theme_classic() + 
  theme(legend.title = element_blank(),
        legend.text = element_markdown(size = axtitle),
        axis.text = element_markdown(size = axtext),
        axis.title.x.top = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle),
        legend.position = "none") +
  guides(shape = guide_legend(override.aes = list(size = 6)))

# print(plot.vmpfc.kV.Sk) 
plot.vmpfc.kV.Sk <- plot.vmpfc.kV.Sk + theme(legend.position = "none")

plot.vmpfc.kV.Ok <- ggplot(df.map.patients, aes(x = k_vox_bin, y = PM_other_k, colour = k_vox_bin, fill = k_vox_bin)) + 
  geom_hline(yintercept = hc.k.other.av, linetype = 'dotted', col = 'grey') +
  stat_summary(fun.data = "mean_cl_boot", geom = "errorbar", conf.int=.95, position=position_dodge(0.75), width = 0, alpha = 1) +
  stat_summary(fun = mean, position=position_dodge(0.75), width = 0.75, color = agent.fills[2], size = 3) +
  geom_jitter(position = position_jitterdodge(dodge.width = 0.75, jitter.height = 0, jitter.width = 0.3), size = 3, show.legend = FALSE, alpha = 0.5) + 
  scale_x_discrete(name = paste0("Area 13a/b damage"), position = "top") +
  scale_y_continuous(name = paste0('*\u039A*<sub>other</sub>'), trans = "reverse") +
  scale_color_manual(values = c(agent.colours[2],agent.colours[2])) +
  scale_fill_manual(values = c(agent.fills[2],agent.fills[2])) +
  theme_classic() + 
  theme(legend.title = element_blank(),
        legend.text = element_markdown(size = axtitle),
        axis.text = element_markdown(size = axtext),
        axis.title.x.top = element_markdown(size = axtitle),
        axis.title.y = element_markdown(size = axtitle)) +
  guides(shape = guide_legend(override.aes = list(size = 6)))

# print(plot.vmpfc.kV.Ok)
plot.vmpfc.map.leg <- get_legend(plot.vmpfc.kV.Ok)
plot.vmpfc.kV.Ok <- plot.vmpfc.kV.Ok + theme(legend.position = "none")

```

# Manuscript

## Methods

### *Participants*

We recruited three groups of participants, one with focal damage to vmPFC and one with lesions elsewhere, 
from a database of 453 neurological patients, as well as healthy age and gender-matched controls from university databases and the community. 
The vmPFC lesion group included 
`r length(demographics$Age[demographics$Group == "vmPFC"])` patients
with vmPFC damage (age
range=`r dem$Age_min[rownames(dem) == "vmPFC"]`-`r dem$Age_max[rownames(dem) == "vmPFC"]`,
mean=`r format(dem$Age_mean[rownames(dem) == "vmPFC"], nsmall=2)`;
`r d.gender[rownames(d.gender) == "vmPFC",1]` females). 
Two other patients with vmPFC lesions took part but were excluded from 
all analyses for not following the task instructions or not understanding the task. 
The lesion control (LC) group included 
`r length(demographics$Age[demographics$Group == "LC"])` patients with
lesions in areas outside vmPFC (age
range=`r dem$Age_min[rownames(dem) == "LC"]`-`r dem$Age_max[rownames(dem) == "LC"]`,
mean=`r format(dem$Age_mean[rownames(dem) == "LC"], nsmall=2)`;
`r d.gender[rownames(d.gender) == "LC",1]` females). 
The healthy control (HC) group included 
`r length(demographics$Age[demographics$Group == "HC"])` 
participants with no brain damage (age
range=`r dem$Age_min[rownames(dem) == "HC"]`-`r dem$Age_max[rownames(dem) == "HC"]`,
mean=`r format(dem$Age_mean[rownames(dem) == "HC"], nsmall=2)`;
`r d.gender[rownames(d.gender) == "HC",1]` females), 
giving a total sample of 
n=`r length(demographics$Age)` 
for group-based analyses. Finally,
`r words(length(demographics.ol$Age[demographics.ol$Group == "OL"]))`
additional patients with lesions affecting more dorsal regions of mPFC
or the anterior cingulate cortex (ACC) also completed the task (age
range=`r dem$Age_min[rownames(dem) == "OL"]`-`r dem$Age_max[rownames(dem) == "OL"]`,
mean=`r format(dem$Age_mean[rownames(dem) == "OL"], nsmall=2)`;
`r d.gender[rownames(d.gender) == "OL",1]` females). 
These patients were only included in the lesion mapping analysis (see below), 
which had a total sample of 45 patients. We did not include patients with dorsal mPFC or 
ACC lesions in the between-group analyses, as the damage was not within the vmPFC region 
of interest, but also was not distinct enough to include in the lesion control group.
Classification of lesion location was done from MR imaging or CT scans 
(see below) by a neurologist (SGM).

Across the vmPFC and LC groups, most lesions were caused by subarachnoid haemorrhage. 
Three patients’ damage was caused by tumour (2 vmPFC, 1 LC) and one LC patient by head injury. 
In all cases, the brain damage occurred at least 24 months prior to testing. 15 out of 45 patients 
were hypertensive (10 vmPFC, 5 LC), four were on antidepressants (1 vmPFC, 3 LC), and 2 took pregabalin (1 vmPFC, 1 LC). 
We carefully screened participants and recruited them such that there were no differences between groups in terms of gender 
(`r "<i>\u03C7</i>"`<sup>2</sup><sub>(`r diff.gender[["parameter"]][["df"]]`)</sub>=
`r format(round(diff.gender[["statistic"]][["X-squared"]], digits=2), nsmall=2)`,
*p*`r pvalrf(diff.gender[["p.value"]])`), age 
(*p*s>`r min(d.means$w_pval_hc_vmPFC[d.means$measure == "Age"], d.means$w_pval_hc_lc[d.means$measure == "Age"], d.means$w_pval_lc_vmPFC[d.means$measure == "Age"])`),
self-reported levels of apathy (Apathy Motivation Index[REF]; 
*p*s>`r format(round(min(d.means$w_pval_hc_vmPFC[d.means$measure == "AMI_tot"], d.means$w_pval_hc_lc[d.means$measure == "AMI_tot"], d.means$w_pval_lc_vmPFC[d.means$measure == "AMI_tot"]), digits=2), nsmall=2)`), or performance on a neuropsychological test of cognitive abilities and visual attention (Trail Making Test[REF]; Part A 
*p*s>`r format(round(min(d.means$w_pval_hc_vmPFC[d.means$measure == "Trail_A"], d.means$w_pval_lc_vmPFC[d.means$measure == "Trail_A"]), digits=2), nsmall=2)`, Part B 
*p*s>`r format(round(min(d.means$w_pval_hc_vmPFC[d.means$measure == "Trail_B"], d.means$w_pval_lc_vmPFC[d.means$measure == "Trail_B"]), digits=2), nsmall=2)`).

The vmPFC group also did not differ from controls in 
depression (Beck Depression Inventory[REF]; 
*p*s>`r format(round(min(d.means$w_pval_hc_vmPFC[d.means$measure == "BDI_total"], d.means$w_pval_lc_vmPFC[d.means$measure == "BDI_total"]), digits=2), nsmall=2)`)


## Results

To establish the impact of vmPFC damage on prosocial behaviour, effort, and reward processing, we compared 
`r length(demographics$Age[demographics$Group == "vmPFC"])` patients with vmPFC damage 
(mean age=`r format(dem$Age_mean[rownames(dem) == "vmPFC"], nsmall=2)`;
`r d.gender[rownames(d.gender) == "vmPFC",1]` females) to two control groups. 
`r length(demographics$Age[demographics$Group == "LC"])` lesion control (LC) patients had damage to areas outside vmPFC 
(mean age=`r format(dem$Age_mean[rownames(dem) == "LC"], nsmall=2)`;
`r d.gender[rownames(d.gender) == "LC",1]` females), and 
`r length(demographics$Age[demographics$Group == "HC"])` healthy control (HC) participants did not have any brain damage 
(mean age=`r format(dem$Age_mean[rownames(dem) == "HC"], nsmall=2)`;
`r d.gender[rownames(d.gender) == "HC",1]` females). 
All participants completed an effort-based decision-making task[REF], 
that independently manipulated effort, reward, and recipient. 
Participants chose between a low-effort, low-reward “rest” option and a 
high-effort high-reward “work” option on each trial. On half of the trials, the reward was for themselves 
(self) and on the other half, the reward was for an anonymous other person (other; see Methods and Figure 2). 
The groups were carefully matched, with no differences in gender, age, cognitive ability, or levels of apathy 
or depression (See Methods and Table S1).  


gender
(`r "<i>\u03C7</i>"`<sup>2</sup><sub>(`r diff.gender[["parameter"]][["df"]]`)</sub>=
`r format(round(diff.gender[["statistic"]][["X-squared"]], digits=2), nsmall=2)`,
*p*`r pvalrf(diff.gender[["p.value"]])`) or age
(*p*s>`r min(d.means$w_pval_hc_vmPFC[d.means$measure == "Age"], d.means$w_pval_hc_lc[d.means$measure == "Age"], d.means$w_pval_lc_vmPFC[d.means$measure == "Age"])`). 
The vmPFC group also did not differ from the control groups in self-reported levels of apathy (Apathy Motivation Index[REF]; 
*p*s>`r format(round(min(d.means$w_pval_hc_vmPFC[d.means$measure == "AMI_tot"], d.means$w_pval_hc_lc[d.means$measure == "AMI_tot"], d.means$w_pval_lc_vmPFC[d.means$measure == "AMI_tot"]), digits=2), nsmall=2)`),
depression (Beck Depression Inventory[REF]; 
*p*s>`r format(round(min(d.means$w_pval_hc_vmPFC[d.means$measure == "BDI_total"], d.means$w_pval_hc_lc[d.means$measure == "BDI_total"], d.means$w_pval_lc_vmPFC[d.means$measure == "BDI_total"]), digits=2), nsmall=2)`)
or performance on a neuropsychological test of cognitive abilities and visual attention (Trail Making Test[REF]; Part A 
*p*s>`r format(round(min(d.means$w_pval_hc_vmPFC[d.means$measure == "Trail_Making_A_(seconds)'"], d.means$w_pval_lc_vmPFC[d.means$measure == "Trail_Making_A_(seconds)'"]), digits=2), nsmall=2)`, Part B 
*p*s>`r format(round(min(d.means$w_pval_hc_vmPFC[d.means$measure == "Trail_Making_B_(seconds)'"], d.means$w_pval_lc_vmPFC[d.means$measure == "Trail_Making_B_(seconds)'"]), digits=2), nsmall=2)`).

### *Patients with vmPFC damage earn less money for the other person*

Our first analysis examined how many credits participants earned for themselves and the other anonymous participant, 
which translated into bonus money for each recipient. We tested whether the number of credits earned differed between 
the three groups (vmPFC, HC, LC) using a generalised linear mixed-effects model (GLMM, see Methods and Table S2). 
Patients with vmPFC damage earned fewer credits for other relative to self, compared to both control groups
(group\*recipient interaction vmPFC vs. HC
b [95% confidence interval]=`r format(round(r.credits$Coefficient[r.credits$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`
[`r format(round(r.credits$CI_low[r.credits$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`,
`r format(round(r.credits$CI_high[r.credits$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`],
*p*`r pvalrf(r.credits$p[r.credits$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. HC)"])`;
vmPFC vs. LC
b=`r format(round(r.credits$Coefficient[r.credits$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. LC)"], digits=2), nsmall=2)`
[`r format(round(r.credits$CI_low[r.credits$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. LC)"], digits=2), nsmall=2)`,
`r format(round(r.credits$CI_high[r.credits$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. LC)"], digits=2), nsmall=2)`],
*p*`r pvalrf(r.credits$p[r.credits$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. LC)"])`; Figure 3A). 
Post-hoc tests revealed that these interactions were driven by the vmPFC group earning significantly fewer credits for the other person, 
compared to both healthy controls 
(ratio=`r format(round(credits.con.all$ratio[credits.con.all$contrast == "other vmPFC / other HC"], digits=2), nsmall=2)`,
SE=`r format(round(credits.con.all$SE[credits.con.all$contrast == "other vmPFC / other HC"], digits=2), nsmall=2)`,
Z=`r format(round(credits.con.all$z.ratio[credits.con.all$contrast == "other vmPFC / other HC"], digits=2), nsmall=2)`,
*p*`r pvalrf(credits.con.all$p.value[credits.con.all$contrast == "other vmPFC / other HC"])`) 
and patients with damage elsewhere (ratio=`r format(round(credits.con.all$ratio[credits.con.all$contrast == "other vmPFC / other LC"], digits=2), nsmall=2)`,
SE=`r format(round(credits.con.all$SE[credits.con.all$contrast == "other vmPFC / other LC"], digits=2), nsmall=2)`,
Z=`r format(round(credits.con.all$z.ratio[credits.con.all$contrast == "other vmPFC / other LC"], digits=2), nsmall=2)`,
*p*`r pvalrf(credits.con.all$p.value[credits.con.all$contrast == "other vmPFC / other LC"])`; Table S2). 

In contrast, vmPFC patients earned the same amount as lesion controls for themselves 
(ratio=`r format(round(credits.con.all$ratio[credits.con.all$contrast == "self vmPFC / self LC"], digits=2), nsmall=2)`, 
*p*`r pvalrf(credits.con.all$p.value[credits.con.all$contrast == "self vmPFC / self LC"])`, 
Bayes factor (BF<sub>01</sub>)=`r format(round(credits.bf01.lc.vmpfc.self$bf, digits=2), nsmall=2)`; see Methods)
and did not significantly differ from healthy controls
ratio=`r format(round(min(credits.con.all$ratio[credits.con.all$contrast == "self vmPFC / self HC"]), digits=2), nsmall=2)`, 
*p*`r pvalrf(credits.con.all$p.value[credits.con.all$contrast == "self vmPFC / self HC"])`, 
BF<sub>01</sub>=`r format(round(credits.bf01.hc.vmpfc.self$bf, digits=2), nsmall=2)`). 
The two control groups did not significantly differ in the number of credits earned for either recipient 
(other ratio=`r format(round(credits.con.all$ratio[credits.con.all$contrast == "other HC / other LC"], digits=2), nsmall=2)`,
SE=`r format(round(credits.con.all$SE[credits.con.all$contrast == "other HC / other LC"], digits=2), nsmall=2)`,
Z=`r format(round(credits.con.all$z.ratio[credits.con.all$contrast == "other HC / other LC"], digits=2), nsmall=2)`,
*p*`r pvalrf(credits.con.all$p.value[credits.con.all$contrast == "other HC / other LC"])`, 
BF<sub>01</sub>=`r format(round(credits.bf01.hc.lc.other$bf, digits=2), nsmall=2)`;
self ratio=`r format(round(credits.con.all$ratio[credits.con.all$contrast == "self HC / self LC"], digits=2), nsmall=2)`,
SE=`r format(round(credits.con.all$SE[credits.con.all$contrast == "self HC / self LC"], digits=2), nsmall=2)`,
Z=`r format(round(credits.con.all$z.ratio[credits.con.all$contrast == "self HC / self LC"], digits=2), nsmall=2)`,
*p*`r pvalrf(credits.con.all$p.value[credits.con.all$contrast == "self HC / self LC"])`, 
BF<sub>01</sub>=`r format(round(credits.bf01.hc.lc.self$bf, digits=2), nsmall=2)`).
Together, these results show that damage, specifically to vmPFC, decreased rewards earned for the other person, 
but not the participant themselves.

#### Figure 2

```{r task-plot, echo = FALSE, cache = TRUE, warning=FALSE, fig.height=7.5, fig.width=12}

task <- "images/task.jpg"
task <- ggdraw() + draw_image(task)

players <- "images/players.jpg"
players <- ggdraw() + draw_image(players)

task.plt <- plot_grid(task, players, ncol = 2, rel_widths = c(2,1), rel_heights = c(1,1), labels = c("a","b"), label_size = axtitle, axis = "tb", align = "h")

task.plt

```
**Figure 2. Effort-based decision-making task with rewards for self or other. (a)** Before any further instructions, participants squeezed as hard as they could to measure their maximum voluntary contraction (MVC) on a handheld dynamometer to threshold each effort level to their strength. After thresholding and practice, participants chose on each trial between a “rest” option, which required no effort (0% MVC, one segment of the pie chart) for a low reward of 1 credit, and a “work” option, which required more effort (30%–70% MVC, 2–6 pie chart segments) and gained more reward (2–10 credits). The reward available and effort required were manipulated independently. After making their choice, participants had to exert the required force (shown by the yellow line) for at least 1s of a 3s window to receive the reward. Visual feedback on the amount of force used was displayed on the screen. Participants then saw the outcome, depending on the offer they had chosen and whether they were successful. If they did not meet the required force level, “0 credits” was displayed. Crucially, on self-trials, participants made the choice, exerted the effort, and received the reward themselves, whereas on other trials (“AMY” in this example), participants made the choice and exerted the effort, but the other participant received the reward. **(b)** Participants were designated as “Player 1” (self) and told that their decisions impacted another player “Player 2” (other) whom they met at the beginning of the testing session with their identity obscured (to control for influences of identity or reciprocity). The name used in the task was gender-matched to the participant. The procedure involved 4 people, two experimenters, EXP1 and EXP2, and two participants, self and other.

### *Damage to vmPFC decreases prosocial behaviour*

To examine what was driving the group difference in the broad measure of credits earned, 
we first considered participants’ willingness to choose the high-effort option over rest. 
Using a binomial GLMM (see Methods), we tested whether vmPFC lesions affected prosociality 
(recipient\*group interaction) in choices. 
Analysing choices on each trial also enabled us to test group differences in sensitivity to rewards (reward level 2-6: 2, 4, 6, 8 or 10 credits) and effort (effort level 2-6: 30, 40, 50, 60 or 70% of maximum, squared to match computational model; see Methods). We also considered the possibility of higher-order interactions by starting with a maximal model containing fixed effects of and all interactions (up to 4-way) between effort, reward, recipient, and group, as well as random effects and all interactions (up to 3-way) between effort, reward, and recipient. Data-driven model reduction suggested that no interaction terms between more than two variables significantly improved the model (see Methods).

Prosociality decreased with vmPFC damage (Table S3). vmPFC patients chose to work to benefit the other person less than both control groups
(vmPFC vs. HC OR=`r format(round(choice.con.all$odds.ratio[choice.con.all$contrast == "other vmPFC / other HC"], digits=2), nsmall=2)`,
SE=`r format(round(choice.con.all$SE[choice.con.all$contrast == "other vmPFC / other HC"], digits=2), nsmall=2)`,
Z=`r format(round(choice.con.all$z.ratio[choice.con.all$contrast == "other vmPFC / other HC"], digits=2), nsmall=2)`,
*p*`r pvalrf(choice.con.all$p.value[choice.con.all$contrast == "other vmPFC / other HC"])`; vmPFC vs. LC
OR=`r format(round(choice.con.all$odds.ratio[choice.con.all$contrast == "other vmPFC / other LC"], digits=2), nsmall=2)`,
SE=`r format(round(choice.con.all$SE[choice.con.all$contrast == "other vmPFC / other LC"], digits=2), nsmall=2)`,
Z=`r format(round(choice.con.all$z.ratio[choice.con.all$contrast == "other vmPFC / other LC"], digits=2), nsmall=2)`,
*p*`r pvalrf(choice.con.all$p.value[choice.con.all$contrast == "other vmPFC / other LC"])`). 
In contrast, the vmPFC group was equally willing to exert effort to benefit themselves compared to both control groups 
(vmPFC vs. HC OR=`r format(round(choice.con.all$odds.ratio[choice.con.all$contrast == "self vmPFC / self HC"], digits=2), nsmall=2)`,
SE=`r format(round(choice.con.all$SE[choice.con.all$contrast == "self vmPFC / self HC"], digits=2), nsmall=2)`,
Z=`r format(round(choice.con.all$z.ratio[choice.con.all$contrast == "self vmPFC / self HC"], digits=2), nsmall=2)`,
*p*`r pvalrf(choice.con.all$p.value[choice.con.all$contrast == "self vmPFC / self HC"])`, 
BF<sub>01</sub>=`r format(round(choices.bf01.hc.vmpfc.self$bf, digits=2), nsmall=2)`; vmPFC vs. LC
OR=`r format(round(choice.con.all$odds.ratio[choice.con.all$contrast == "self vmPFC / self LC"], digits=2), nsmall=2)`,
SE=`r format(round(choice.con.all$SE[choice.con.all$contrast == "self vmPFC / self LC"], digits=2), nsmall=2)`,
Z=`r format(round(choice.con.all$z.ratio[choice.con.all$contrast == "self vmPFC / self LC"], digits=2), nsmall=2)`,
*p*`r pvalrf(choice.con.all$p.value[choice.con.all$contrast == "self vmPFC / self LC"])`, 
BF<sub>01</sub>=`r format(round(choices.bf01.lc.vmpfc.self$bf, digits=2), nsmall=2)`).
Finally, the two control groups did not significantly differ in willingness to exert effort for self or other, 
although these contrasts were not sensitive enough to support evidence of no difference 
(self OR=`r format(round(choice.con.all$odds.ratio[choice.con.all$contrast == "self HC / self LC"], digits=2), nsmall=2)`,
SE=`r format(round(choice.con.all$SE[choice.con.all$contrast == "self HC / self LC"], digits=2), nsmall=2)`,
Z=`r format(round(choice.con.all$z.ratio[choice.con.all$contrast == "self HC / self LC"], digits=2), nsmall=2)`,
*p*`r pvalrf(choice.con.all$p.value[choice.con.all$contrast == "self HC / self LC"])`,
BF<sub>01</sub>=`r format(round(choices.bf01.hc.lc.self$bf, digits=2), nsmall=2)`; 
other OR=`r format(round(choice.con.all$odds.ratio[choice.con.all$contrast == "other HC / other LC"], digits=2), nsmall=2)`,
SE=`r format(round(choice.con.all$SE[choice.con.all$contrast == "other HC / other LC"], digits=2), nsmall=2)`,
Z=`r format(round(choice.con.all$z.ratio[choice.con.all$contrast == "other HC / other LC"], digits=2), nsmall=2)`,
*p*`r pvalrf(choice.con.all$p.value[choice.con.all$contrast == "other HC / other LC"])`,
BF<sub>01</sub>=`r format(round(choices.bf01.hc.lc.other$bf, digits=2), nsmall=2)`).

#### Figure 3

```{r behav-plot, echo = FALSE, warning=FALSE, fig.height=10, fig.width=8}

# behav.plt <- plot_grid(credit.plt, choice.plt, k.plt, ncol = 3, rel_widths = c(1,1,1), labels = c("a","b","c"), label_size = axtitle, axis = "tb", align = "vh")

behav.plt <- plot_grid(credit.plt, choice.plt, choice.e.plt, choice.r.plt, ncol = 2, labels = "auto", label_size = axtitle, axis = "tbrl", align = "vh")

print(behav.plt)

```
<br>
**Figure 3. Damage to vmPFC decreases prosociality and effort sensitivity.** 
vmPFC lesions decreased willingness to help others measured as 
**(a)** earning fewer credits for the other player, 
but not for themselves, **(b)** 
accepting fewer high-effort high-reward “work” offers for other, but not themselves. 
Asterisks between groups represent significant interactions between the recipient 
(self or other) and group in the (G)LMM. Asterisks between self and other represent 
significant differences (p<0.05) within each group in post-hoc comparisons. Significance 
for comparisons between groups for each recipient are not depicted but show the significant 
recipient\*group interactions are driven by vmPFC patients earning significantly fewer credits 
and accepting significantly fewer work offers for the other person, compared to both control groups
(*p*s<`r format(round(max(credits.con.all$p.value[credits.con.all$contrast == "other HC / other vmPFC"], credits.con.all$p.value[credits.con.all$contrast == "other vmPFC / other LC"], choice.con.all$p.value[choice.con.all$contrast == "other HC / other vmPFC"], choice.con.all$p.value[choice.con.all$contrast == "other vmPFC / other LC"]), digits=2), nsmall=2)`; see Results).
In contrast, there were no significant differences between vmPFC patients 
and the control groups in self-benefitting decision-making 
(*p*s>`r format(round(min(credits.con.all$p.value[credits.con.all$contrast == "self HC / self vmPFC"], credits.con.all$p.value[credits.con.all$contrast == "self vmPFC / self LC"], choice.con.all$p.value[choice.con.all$contrast == "self HC / self vmPFC"], choice.con.all$p.value[choice.con.all$contrast == "self vmPFC / self LC"], k.con.all$p.value[k.con.all$contrast == "self HC / self vmPFC"], k.con.all$p.value[k.con.all$contrast == "self vmPFC / self LC"]), digits=2), nsmall=2)`) and 
there was Bayesian evidence of no difference between groups in credits earned (vs. LC) and choices to work for self-benefitting rewards
`r format(round(min(choices.bf01.hc.vmpfc.self$bf, choices.bf01.lc.vmpfc.self$bf,  credits.bf01.lc.vmpfc.self$bf), digits=2), nsmall=2)`<BF<sub>01</sub><`r format(round(max(choices.bf01.hc.vmpfc.self$bf, choices.bf01.lc.vmpfc.self$bf, credits.bf01.lc.vmpfc.self$bf), digits=2), nsmall=2)`.
**(c)** The effect of effort on decision-making differed between vmPFC patients and participants 
without brain damage (estimates from generalised linear mixed-effects model (GLMM) of binary choices between work and rest; group\*effort interaction 
OR=`r format(round(r.choice$Coefficient[r.choice$Parameter == "Effort * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`
[`r format(round(r.choice$CI_low[r.choice$Parameter == "Effort * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`,
`r format(round(r.choice$CI_high[r.choice$Parameter == "Effort * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`],
*p*`r pvalrf(r.choice$p[r.choice$Parameter == "Effort * Group (vmPFC vs. HC)"])`).
This group difference in effort sensitivity was driven by vmPFC patients’ reduced willingness to accept the work offer at the 
lower effort levels compared to healthy controls. Asterisks represent significant differences (*p*<0.05) in post-hoc comparisons 
at each effort level. **(d)** In contrast, there were no significant group differences in how reward affected decisions. 
All three groups were more willing to exert effort as the reward available increased, and there was no evidence that this 
sensitivity to reward was significantly different in the vmPFC group.

higher discounting of rewards by
effort (`r "<i>\u039A</i>"`) for other relative to self.
Asterisks between groups represent significant interactions (*p*\<0.05) between recipient 
(self or other) and group in the (G)LMM. 
Asterisks between self and other represent significant differences (*p*\<0.05) in post-hoc
comparisons based on (G)LMMs with the relevant link function for the
data distribution (gamma for credits, binomial for choices, log for `r "<i>\u039A</i>"`). 
Results of post-hoc comparisons between groups for each recipient are not depicted but showed 
the significant recipient\*group interactions are driven by vmPFC patients earning significantly 
fewer credits and accepting significantly fewer work offers for the other person, compared to both control groups 
(*p*s<`r format(round(max(credits.con.all$p.value[credits.con.all$contrast == "other HC / other vmPFC"], credits.con.all$p.value[credits.con.all$contrast == "other vmPFC / other LC"], choice.con.all$p.value[choice.con.all$contrast == "other HC / other vmPFC"], choice.con.all$p.value[choice.con.all$contrast == "other vmPFC / other LC"]), digits=2), nsmall=2)`; 
Table S2, Table S4 & Table S6). In contrast, there were no significant differences between vmPFC patients 
and the control groups in self-benefitting decision-making for credits, 
choices or `r "<i>\u039A</i>"` parameters
(*p*s>`r format(round(min(credits.con.all$p.value[credits.con.all$contrast == "self HC / self vmPFC"], credits.con.all$p.value[credits.con.all$contrast == "self vmPFC / self LC"], choice.con.all$p.value[choice.con.all$contrast == "self HC / self vmPFC"], choice.con.all$p.value[choice.con.all$contrast == "self vmPFC / self LC"], k.con.all$p.value[k.con.all$contrast == "self HC / self vmPFC"], k.con.all$p.value[k.con.all$contrast == "self vmPFC / self LC"]), digits=2), nsmall=2)`) and 
there was Bayesian evidence of no difference between groups in credits earned and choices to work for self-benefitting rewards.

### *vmPFC lesions alter effort sensitivity*

Analysis of sensitivity to effort also revealed a significant difference between healthy controls and vmPFC patients 
(group\*effort interaction OR=`r format(round(r.choice$Coefficient[r.choice$Parameter == "Effort * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`
[`r format(round(r.choice$CI_low[r.choice$Parameter == "Effort * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`,
`r format(round(r.choice$CI_high[r.choice$Parameter == "Effort * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`],
*p*`r pvalrf(r.choice$p[r.choice$Parameter == "Effort * Group (vmPFC vs. HC)"])`; Figure 3C).
Healthy control participants accepted a high
number of work offers at the lower effort levels (level 2 
mean=`r format(round(mean(df$Choice.r[df$Effort.f == 2 & df$Group == "HC"]), digits=2), nsmall=2)`),
but willingness to work dropped dramatically when more effort was required (level 6 
mean=`r format(round(mean(df$Choice.r[df$Effort.f == 5 & df$Group == "HC"]), digits=2), nsmall=2)`).
This meant higher effort had a large negative effect on choices for healthy controls (effort effect 
[confidence level]=`r format(round(choice.con.eg$Effort.trend[choice.con.eg$Group_vmpfc == "HC"], digits=2), nsmall=2)`
[`r format(round(choice.con.eg$asymp.LCL[choice.con.eg$Group_vmpfc == "HC"]), digits=2, nsmall=2)`,
`r format(round(choice.con.eg$asymp.UCL[choice.con.eg$Group_vmpfc == "HC"]), digits=2, nsmall=2)`]).
In contrast, while vmPFC patients were also less willing to work when more effort was required, 
the effect of effort on choices was significantly less negative 
(effect=`r format(round(choice.con.eg$Effort.trend[choice.con.eg$Group_vmpfc == "vmPFC"], digits=2), nsmall=2)`
[`r format(round(choice.con.eg$asymp.LCL[choice.con.eg$Group_vmpfc == "vmPFC"], digits=2), nsmall=2)`,
`r format(round(choice.con.eg$asymp.UCL[choice.con.eg$Group_vmpfc == "vmPFC"], digits=2), nsmall=2)`]).
This group difference in how effort affected choices was due to vmPFC patients accepting relatively fewer 
work offers than healthy controls when the effort required was minimal (level 2 
mean=`r format(round(mean(df$Choice.r[df$Effort.f == 2 & df$Group == "vmPFC"]), digits=2), nsmall=2)`),
but a similar willingness to work at the highest effort level (level 6
mean=`r format(round(mean(df$Choice.r[df$Effort.f == 5 & df$Group == "vmPFC"]), digits=2), nsmall=2)`; Figure 3C).
Follow-up analyses showed reduced effort sensitivity in vmPFC patients compared to healthy controls for both recipients 
(self OR=`r format(round(r.choice.self$Coefficient[r.choice.self$Parameter == "Effort * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`
[`r format(round(r.choice.self$CI_low[r.choice.self$Parameter == "Effort * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`,
`r format(round(r.choice.self$CI_high[r.choice.self$Parameter == "Effort * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`],
*p*`r pvalrf(r.choice.self$p[r.choice.self$Parameter == "Effort * Group (vmPFC vs. HC)"])`;
other OR=`r format(round(r.choice.other$Coefficient[r.choice.other$Parameter == "Effort * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`
[`r format(round(r.choice.other$CI_low[r.choice.other$Parameter == "Effort * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`,
`r format(round(r.choice.other$CI_high[r.choice.other$Parameter == "Effort * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`],
*p*`r pvalrf(r.choice.other$p[r.choice.other$Parameter == "Effort * Group (vmPFC vs. HC)"])`).
Effort also negatively affected lesion control patients’ willingness to work, but this did not significantly differ from the other groups (LC vs. vmPFC GLMM
group\*effort interaction OR=`r format(round(r.choice$Coefficient[r.choice$Parameter == "Effort * Group (vmPFC vs. LC)"], digits=2), nsmall=2)`
[`r format(round(r.choice$CI_low[r.choice$Parameter == "Effort * Group (vmPFC vs. LC)"], digits=2), nsmall=2)`,
`r format(round(r.choice$CI_high[r.choice$Parameter == "Effort * Group (vmPFC vs. LC)"], digits=2), nsmall=2)`],
*p*`r pvalrf(r.choice$p[r.choice$Parameter == "Effort * Group (vmPFC vs. LC)"])`; LC vs. HC post-hoc 
interaction=`r format(round(choice.con.inter.eg$estimate[choice.con.inter.eg$contrast == "HC - LC"], digits=2), nsmall=2)`,
SE=`r format(round(choice.con.inter.eg$SE[choice.con.inter.eg$contrast == "HC - LC"], digits=2), nsmall=2)`,
Z=`r format(round(choice.con.inter.eg$z.ratio[choice.con.inter.eg$contrast == "HC - LC"], digits=2), nsmall=2)`,
*p*`r pvalrf(choice.con.inter.eg$p.value[choice.con.inter.eg$contrast == "HC - LC"])`).

Analysis of sensitivity to reward showed participants in all three groups chose to work more when a larger reward was available 
(vmPFC GLMM OR=`r format(round(r.choice$Coefficient[r.choice$Parameter == "Reward"], digits=2), nsmall=2)`
[`r format(round(r.choice$CI_low[r.choice$Parameter == "Reward"], digits=2), nsmall=2)`,
`r format(round(r.choice$CI_high[r.choice$Parameter == "Reward"], digits=2), nsmall=2)`],
*p*`r pvalrf(r.choice$p[r.choice$Parameter == "Reward"])`; Figure 3D).
Across groups, we observed that people were more likely to choose the higher effort option as reward increased, 
and when the reward was for themselves compared to another person (recipient\*reward interaction
OR=`r format(round(r.choice$Coefficient[r.choice$Parameter == "Reward * Recipient (Self vs. Other)"], digits=2), nsmall=2)`
[`r format(round(r.choice$CI_low[r.choice$Parameter == "Reward * Recipient (Self vs. Other)"], digits=2), nsmall=2)`,
`r format(round(r.choice$CI_high[r.choice$Parameter == "Reward * Recipient (Self vs. Other)"], digits=2), nsmall=2)`],
*p*`r pvalrf(r.choice$p[r.choice$Parameter == "Reward * Recipient (Self vs. Other)"])`).
However, of group differences in reward processing (Figure 3D). The group\*reward interaction was not selected as a term in 
the GLMM and there was strong evidence against adding it to the best-fitting model 
(`r "\u0394"` deviance 
`r "<i>\u03C7</i>"`<sup>2</sup><sub>(`r anova.RGinter$Df[2]`)</sub>=`r format(round(anova.RGinter$Chisq[2], digits=2), nsmall=2)`,
*p*`r pvalrf(anova.RGinter$P[2])`,
`r "\u0394"` BIC=`r anova.RGinter$BIC[2] - anova.RGinter$BIC[1]`, BF<sub>01</sub>=`r format(round(bf01.RGinter, digits=2), nsmall=2)`).

As expected, the GLMM of choices also showed participants overall chose to work more when
rewards were for themselves, compared to someone else
(OR=`r format(round(r.choice$Coefficient[r.choice$Parameter == "Recipient (Self vs. Other)"], digits=2), nsmall=2)`
[`r format(round(r.choice$CI_low[r.choice$Parameter == "Recipient (Self vs. Other)"], digits=2), nsmall=2)`,
`r format(round(r.choice$CI_high[r.choice$Parameter == "Recipient (Self vs. Other)"], digits=2), nsmall=2)`],
*p*`r pvalrf(r.choice$p[r.choice$Parameter == "Recipient (Self vs. Other)"])`), 
also showed that the increase in willingness to work as the reward available
increased was larger when the reward was for themselves (effect of reward for
self=`r format(round(choice.con.ar$Reward.trend[choice.con.ar$Recipient_s2z == "self"], digits=2), nsmall=2)`
[`r format(round(choice.con.ar$asymp.LCL[choice.con.ar$Recipient_s2z == "self"], digits=2), nsmall=2)`,
`r format(round(choice.con.ar$asymp.UCL[choice.con.ar$Recipient_s2z == "self"], digits=2), nsmall=2)`]),
compared to someone else (effect of reward for
other=`r format(round(choice.con.ar$Reward.trend[choice.con.ar$Recipient_s2z == "other"], digits=2), nsmall=2)`
[`r format(round(choice.con.ar$asymp.LCL[choice.con.ar$Recipient_s2z == "other"], digits=2), nsmall=2)`,
`r format(round(choice.con.ar$asymp.UCL[choice.con.ar$Recipient_s2z == "other"], digits=2), nsmall=2)`]). 

### *Reward devaluation by effort depends on recipient*

So far, we have shown vmPFC damage has a detrimental impact on prosocial decision-making, and that this is at least partially due to vmPFC patients’ lower willingness to exert effort for prosocial rewards, compared to both control groups. Next, we fitted computational models of effort-discounting to participants’ choice behaviour to precisely quantify how the effort required was integrated with the reward available to determine choices for self or other. Importantly, these models separate the extent to which effort devalues the reward (discounting `r "<i>\u039A</i>"` parameter) 
from choice consistency (stochasticity `r "<i>\u03B2</i>"` (beta) parameter) and therefore allow us to test which of these parameters differ 
between recipients and groups.

We fit and compared multiple models to participants' 
choice behaviour using a hierarchical expectation maximisation approach... [paragraph only in word doc for refs]. 
We also established the robustness of our winning model and model
comparison procedure using simulated data. These simulations showed good
recovery of all parameters
(`r paste0("<i>\u039A</i>","<sub>self</sub>","\u003D",format(round(df.pr$HCorr[df.pr$Simulated == 1 & df.pr$Recovered == 1], digits=2), nsmall=2))`,
`r paste0("<i>\u039A</i>","<sub>other</sub>","\u003D",format(round(df.pr$HCorr[df.pr$Simulated == 2 & df.pr$Recovered == 2], digits=2), nsmall=2))`,
`r paste0("<i>\u03B2</i>","<sub>self</sub>","\u003D",format(round(df.pr$HCorr[df.pr$Simulated == 3 & df.pr$Recovered == 3], digits=2), nsmall=2))`,
`r paste0("<i>\u03B2</i>","<sub>other</sub>","\u003D",format(round(df.pr$HCorr[df.pr$Simulated == 4 & df.pr$Recovered == 4], digits=2), nsmall=2))`)
and that the models were identifiable (see Supplementary Methods and
Figure 4).

#### Figure 4

```{r model-plot, echo = FALSE, warning=FALSE, fig.height=10, fig.width=12}

# model.plot2 <- plot_grid(k.sim.plt, ml.plot, nrow = 2, align = "v", axis = "lr", labels = c("", ""), label_size = axtitle)

model.plot2 <- plot_grid(k.sim.plt, ml.plot, nrow = 2, align = "v", axis = "lr", labels = c("b", "d"), label_size = axtitle)

# model.plot1 <- plot_grid(bic.plt, xp.plot, nrow = 2, align = "v", axis = "lr", labels = c("a", "c"), label_size = axtitle)

model.plot1 <- plot_grid(bic.plt, xp.plot, nrow = 2, align = "v", axis = "lr", labels = c("", ""), label_size = axtitle)

# model.plot0 <- plot_grid(bic.lab, NA, nrow = 2, labels = c("b", "d"), label_size = axtitle)

model.plot0 <- plot_grid(bic.lab, k.lab.high, nrow = 2, labels = c("b", "d"), label_size = axtitle)

# model.plot <- plot_grid(model.plot0, model.plot1, model.plot2, ncol = 3, align = "h", axis = "tb", rel_widths = c(0.1,1,1))

model.plot.left <- plot_grid(xp.plot, ml.plot, nrow = 2, axis = "lr", labels = c("a", "c"), label_size = axtitle)

# k.plt <- plot_grid(k.plt, NA, ncol = 2, rel_widths = c(1,0.3))
k.plt <- k.plt + theme(plot.margin = margin(r = 3,  # Right margin
                             l = 1,  # Left margin
                             unit = "cm")) 

model.plot.right <- plot_grid(bic.plt, k.plt, nrow = 2, rel_widths = c(1,0.7))

# model.plot <- plot_grid(xp.plot, bic.plt, ml.plot, k.plt, nrow = 2, align = "hv", axis = "tblr", labels = c("", "b", "", "d"), label_size = axtitle)

# model.plot <- plot_grid(model.plot0, model.plot, ncol = 2, align = "hv", axis = "tb", rel_widths = c(0.1,2))

model.plot <- plot_grid(model.plot.left, model.plot0, model.plot.right, ncol = 3, axis = "tb", rel_widths = c(1.5,0.15,1.5))

print(model.plot)

```
**Figure 4. A computational neurology approach reveals vmPFC damage increases discounting of rewards for other by effort. (a)** 
Results of model identifiability analysis show a strong diagonal across the majority of the average exceedance probability confusion matrix, meaning the models of interest can be accurately identified. We simulated ten datasets each with 100 artificial agents, using each of the 12 models. Parameters were drawn at random from a flat distribution between the upper and lower bounds used when fitting the model to participant data 
(0<`r "<i>\u039A</i>"`<1.5, 0`r "<i>\u03B2</i>"`<4). We then fit each dataset using the same model fitting and comparison procedure applied to participant data and plotted the confusion matrix from the exceedance probability averaged across the ten runs. **(b)** Model comparison of the 12 candidate models shows the 2`r "<i>\u039A</i>"`2`r "<i>\u03B2</i>"` parabolic model best fits the participant data based on multiple fit metrics. This model had a parabolic discounting function and contained separate discounting and choice stochasticity parameters for self and other. It had the highest exceedance probability (XP=1), lowest integrated BIC, and explained the highest proportion of variance in choices (R`r "<sup>2</sup>"`=0.87). **(c)** Strong parameter recovery for the 2`r "<i>\u039A</i>"`2`r "<i>\u03B2</i>"` is shown by the high correlations on the diagonal between simulated and recovered parameter values and low off-diagonal correlations. Simulations for parameter recovery used a grid of values for `r "<i>\u039A</i>"` (0, 0.3, 0.6, 0.9, 1.2, 1.5) and `r "<i>\u03B2</i>"` (0, 1, 2, 3, 4), with added noise drawn from a normal distribution * 0.05, to cover the full range of possible values. **(d)** Comparing discounting `r "<i>\u039A</i>"` parameters
from the winning model between recipients and groups shows vmPFC damage increases discounting of prosocial rewards. Asterisks between groups represent significant interactions between the recipient (self or other) and group in the (G)LMM. Asterisks between self and other represent significant differences (*p*<0.05) within each group in post-hoc comparisons. 

### *vmPFC lesions increase the discounting of prosocial rewards by effort*

After establishing the 2`r "<i>\u039A</i>"`2`r "<i>\u03B2</i>"` model
was robust and best fit the data, we assessed whether the estimated
`r "<i>\u039A</i>"` parameters differed between the three groups and two recipients 
using a  GLMM. All groups showed higher effort discounting of rewards for other compared to self (Figure
3, Table S1 and Table S2) indicating that the
bias towards helping oneself, reported previously, occurs regardless of
lesion location. However, as with the analysis of credits earned and choices to work, 
damage to vmPFC specifically decreased prosociality on this measure. 
The effort required to obtain rewards devalued prosocial rewards to a greater extent 
than self-benefitting rewards for the patients with vmPFC damage, 
compared to both control participants with lesions
elsewhere (group\*recipient interaction 
b=`r format(round(r.k$Coefficient[r.k$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. LC)"], digits=2), nsmall=2)`
[`r format(round(r.k$CI_low[r.k$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. LC)"], digits=2), nsmall=2)`,
`r format(round(r.k$CI_high[r.k$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. LC)"], digits=2), nsmall=2)`],
*p*`r pvalrf(r.k$p[r.k$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. LC)"])`)
and participants without lesions
(b=`r format(round(r.k$Coefficient[r.k$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`
[`r format(round(r.k$CI_low[r.k$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`,
`r format(round(r.k$CI_high[r.k$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`],
*p*`r pvalrf(r.k$p[r.k$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. HC)"])`; 
Figure 2 and Table S2). Post-hoc and Bayesian contrasts comparing patients with vmPFC to control lesions
showed effort discounting for self was the same regardless of lesion location 
(ratio=`r format(round(k.con.all$ratio[k.con.all$contrast == "self vmPFC / self LC"], digits=2), nsmall=2)`,
SE=`r format(round(k.con.all$SE[k.con.all$contrast == "self vmPFC / self LC"], digits=2), nsmall=2)`,
Z=`r format(round(k.con.all$z.ratio[k.con.all$contrast == "self vmPFC / self LC"], digits=2), nsmall=2)`,
*p*`r pvalrf(k.con.all$p.value[k.con.all$contrast == "self vmPFC / self LC"])`,
BF<sub>01</sub>=`r format(round(k.bf01.lc.vmpfc.self$bf, digits=2), nsmall=2)`), 
whereas damage to vmPFC specifically increased how much rewards for another person were discounted by the effort required 
(ratio=`r format(round(k.con.all$ratio[k.con.all$contrast == "other vmPFC / other LC"], digits=2), nsmall=2)`,
SE=`r format(round(k.con.all$SE[k.con.all$contrast == "other vmPFC / other LC"], digits=2), nsmall=2)`,
Z=`r format(round(k.con.all$z.ratio[k.con.all$contrast == "other vmPFC / other LC"], digits=2), nsmall=2)`,
*p*`r pvalrf(k.con.all$p.value[k.con.all$contrast == "other vmPFC / other LC"])`). 
Comparing vmPFC patients with healthy controls showed this significant group\*recipient interaction was also driven by vmPFC patients discounting 
rewards for other relative to self more than healthy controls (Figure 2), although comparing each recipient separately between these groups 
did not show either significant differences or evidence of no difference 
(self ratio=`r format(round(k.con.all$ratio[k.con.all$contrast == "self vmPFC / self HC"], digits=2), nsmall=2)`,
SE=`r format(round(k.con.all$SE[k.con.all$contrast == "self vmPFC / self HC"], digits=2), nsmall=2)`,
Z=`r format(round(k.con.all$z.ratio[k.con.all$contrast == "self vmPFC / self HC"], digits=2), nsmall=2)`,
*p*`r pvalrf(k.con.all$p.value[k.con.all$contrast == "self vmPFC / self HC"])`,
BF<sub>01</sub>=`r format(round(k.bf01.hc.vmpfc.self$bf, digits=2), nsmall=2)`; 
other ratio=`r format(round(k.con.all$ratio[k.con.all$contrast == "other vmPFC / other HC"], digits=2), nsmall=2)`,
SE=`r format(round(k.con.all$SE[k.con.all$contrast == "other vmPFC / other HC"], digits=2), nsmall=2)`,
Z=`r format(round(k.con.all$z.ratio[k.con.all$contrast == "other vmPFC / other HC"], digits=2), nsmall=2)`,
*p*`r pvalrf(k.con.all$p.value[k.con.all$contrast == "other vmPFC / other HC"])`, 
BF<sub>01</sub>=`r format(round(k.bf01.hc.vmpfc.other$bf, digits=2), nsmall=2)`). 
The two control groups also did not significantly differ in discounting for self or other, but these contrasts 
also lacked the sensitivity to support evidence of no difference 
(self ratio=`r format(round(k.con.all$ratio[k.con.all$contrast == "self HC / self LC"], digits=2), nsmall=2)`,
SE=`r format(round(k.con.all$SE[k.con.all$contrast == "self HC / self LC"], digits=2), nsmall=2)`,
Z=`r format(round(k.con.all$z.ratio[k.con.all$contrast == "self HC / self LC"], digits=2), nsmall=2)`,
*p*`r pvalrf(k.con.all$p.value[k.con.all$contrast == "self HC / self LC"])`,
BF<sub>01</sub>=`r format(round(k.bf01.hc.lc.self$bf, digits=2), nsmall=2)`; 
other ratio=`r format(round(k.con.all$ratio[k.con.all$contrast == "other HC / other LC"], digits=2), nsmall=2)`,
SE=`r format(round(k.con.all$SE[k.con.all$contrast == "other HC / other LC"], digits=2), nsmall=2)`,
Z=`r format(round(k.con.all$z.ratio[k.con.all$contrast == "other HC / other LC"], digits=2), nsmall=2)`,
*p*`r pvalrf(k.con.all$p.value[k.con.all$contrast == "other HC / other LC"])`, 
BF<sub>01</sub>=`r format(round(k.bf01.hc.lc.other$bf, digits=2), nsmall=2)`). 

Prosociality did not differ between the control groups (post-hoc group\*recipient 
interaction=`r format(round(k.con.all$ratio[k.con.all$contrast == "(self / other HC) / (self / other LC)"], digits=2), nsmall=2)`,
SE=`r format(round(k.con.all$SE[k.con.all$contrast == "(self / other HC) / (self / other LC)"], digits=2), nsmall=2)`,
Z=`r format(round(k.con.all$z.ratio[k.con.all$contrast == "(self / other HC) / (self / other LC)"], digits=2), nsmall=2)`,
*p*`r pvalrf(k.con.all$p.value[k.con.all$contrast == "(self / other HC) / (self / other LC)"])`

We used the same approach to examine whether vmPFC damage results
in differences in decision noise (stochasticity `r "<i>\u03B2</i>"`
parameter) in an LMM. Across all groups, participants made noisier decisions in 
the prosocial compared to the self-benefiting condition 
(*p*s`r pvalrf(min(beta.con.all$p.value[beta.con.all$contrast == "self vmPFC - other vmPFC"], beta.con.all$p.value[beta.con.all$contrast == "self LC - other LC"], beta.con.all$p.value[beta.con.all$contrast == "self HC - other HC"]))`; Figure S1, Table S3 & Table S4). 
In other words, when choosing whether to work to gain rewards for
someone else, participants choices less closely followed the relative
value of working compared to resting. However, unlike the
`r "<i>\u039A</i>"` parameters, there was no evidence this self-other
difference in `r "<i>\u03B2</i>"` parameters was significantly affected by vmPFC
damage (LMM group\*recipient interactions 
*p*s>`r min(r.beta$p[r.beta$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. LC)"], r.beta$p[r.beta$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. HC)"])`). 
Overall levels of decision noise, across the prosocial and
self-benefiting conditions, also did not significantly differ between
the groups (Table S4).

### *Patients with vmPFC damage exert less force to help another person*

Decreased prosocial choices and increased effort discounting of prosocial rewards 
in vmPFC patients at least partially explain why this group earned less credits for the other person 
than both control groups. Our final behavioural analysis considered how much force participants 
exerted after choosing the work option. This could also contribute to reduced prosocial outcomes overall as 
participants earn no credits on trials they choose to work but then do not exert enough force (unsuccessful trials). 
Analysing force within successful trials also provides a complementary measure to choices and discounting that 
captures how much participants energise actions that benefit themselves and others.
As with the choice data, we modelled force (normalised area under the
curve, see Methods) by reducing a maximal LMM that contained fixed
effects of and all interactions (up to 4-way) between effort, reward,
recipient and group, as well as random effects and all interactions (up
to 3-way) between effort, reward and recipient. Here, we focus on interaction 
terms that include group to examine differences between the groups
(see Table S7 for full results).

Patients with vmPFC damage exerted less force for other relative to self
compared to healthy controls (group\*recipient interaction
b=`r format(round(r.force1$Coefficient[r.force1$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. HC)"], digits=3), nsmall=3)`
[`r format(round(r.force1$CI_low[r.force1$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. HC)"], digits=3), nsmall=3)`,
`r format(round(r.force1$CI_high[r.force1$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. HC)"], digits=3), nsmall=3)`],
*p*`r pvalrf(r.force1$p[r.force1$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. HC)"])`), 
particularly at higher effort levels (group\*recipient\*effort
interaction
b=`r format(round(r.force1$Coefficient[r.force1$Parameter == "Effort * Recipient (Self vs. Other) * Group (vmPFC vs. HC)"], digits=3), nsmall=3)`
[`r format(round(r.force1$CI_low[r.force1$Parameter == "Effort * Recipient (Self vs. Other) * Group (vmPFC vs. HC)"], digits=3), nsmall=3)`,
`r format(round(r.force1$CI_high[r.force1$Parameter == "Effort * Recipient (Self vs. Other) * Group (vmPFC vs. HC)"], digits=3), nsmall=3)`],
*p*`r pvalrf(r.force1$p[r.force1$Parameter == "Effort * Recipient (Self vs. Other) * Group (vmPFC vs. HC)"])`) 
and when the reward available was lower
(group\*recipient\*effort\*reward interaction
b=`r format(round(r.force1$Coefficient[r.force1$Parameter == "Effort * Recipient (Self vs. Other) * Reward * Group (vmPFC vs. HC)"], digits=3), nsmall=3)`
[`r format(round(r.force1$CI_low[r.force1$Parameter == "Effort * Recipient (Self vs. Other) * Reward * Group (vmPFC vs. HC)"], digits=3), nsmall=3)`,
`r format(round(r.force1$CI_high[r.force1$Parameter == "Effort * Recipient (Self vs. Other) * Reward * Group (vmPFC vs. HC)"], digits=3), nsmall=3)`],
*p*`r pvalrf(r.force1$p[r.force1$Parameter == "Effort * Recipient (Self vs. Other) * Reward * Group (vmPFC vs. HC)"])`;
Figure 4). This sensitivity to effort and reward in determining the
force exerted when rewards were for another person is evidence against
the idea that vmPFC damage meant patients were not attending to the details
of the work offer in the prosocial condition. 
Interestingly, in a second analysis, limited to trials on which the participant successfully
exerted at least the required level of force,
there was no evidence that any of these interactions improved the model
fit and they did not feature in the best model (Table S8). This suggests that 
patients with vmPFC damage sometimes under-exerted force after 
deciding to help the other person, particularly at high effort and low reward levels, 
and therefore did not always exert enough force to obtain the prosocial reward, a pattern we
previously termed 'superficial prosociality'. High average success rates across trials in 
all three groups demonstrates that superficial prosociality among vmPFC patients was 
not due to issues accurately exerting the required force overall 
(vmPFC mean=`r format(round(success.per$mean_success[success.per$Group == "vmPFC"], digits=2), nsmall=2)`%, 
HC mean=`r format(round(success.per$mean_success[success.per$Group == "HC"], digits=2), nsmall=2)`%, 
LC mean=`r format(round(success.per$mean_success[success.per$Group == "LC"], digits=2), nsmall=2)`%).
When contrasting patients with damage to vmPFC to patients
with damage elsewhere, the only significant interaction was with effort, in 
the analysis limited to successful trials
(b=`r format(round(r.force2$Coefficient[r.force2$Parameter == "Effort * Group (vmPFC vs. LC)"], digits=3), nsmall=3)`
[`r format(round(r.force2$CI_low[r.force2$Parameter == "Effort * Group (vmPFC vs. LC)"], digits=3), nsmall=3)`,
`r format(round(r.force2$CI_high[r.force2$Parameter == "Effort * Group (vmPFC vs. LC)"], digits=3), nsmall=3)`],
*p*`r pvalrf(r.force2$p[r.force2$Parameter == "Effort * Group (vmPFC vs. LC)"])`).
However, lesion control patients also differed from healthy controls in this analysis 
(post-hoc group\*effort interaction=`r format(round(force1.con.inter.eg$estimate[force1.con.inter.eg$contrast == "HC - LC"], digits=2), nsmall=2)`,
SE=`r format(round(force1.con.inter.eg$SE[force1.con.inter.eg$contrast == "HC - LC"], digits=2), nsmall=2)`,
Z=`r format(round(force1.con.inter.eg$z.ratio[force1.con.inter.eg$contrast == "HC - LC"], digits=2), nsmall=2)`,
*p*`r pvalrf(force1.con.inter.eg$p.value[force1.con.inter.eg$contrast == "HC - LC"])`), whereas healthy 
controls and vmPFC patients did not significantly differ 
(LMM group\*effort interaction b=`r format(round(r.force2$Coefficient[r.force2$Parameter == "Effort * Group (vmPFC vs. HC)"], digits=3), nsmall=3)`
[`r format(round(r.force2$CI_low[r.force2$Parameter == "Effort * Group (vmPFC vs. HC)"], digits=3), nsmall=3)`,
`r format(round(r.force2$CI_high[r.force2$Parameter == "Effort * Group (vmPFC vs. HC)"], digits=3), nsmall=3)`],
*p*`r pvalrf(r.force2$p[r.force2$Parameter == "Effort * Group (vmPFC vs. HC)"])`). 
As patients in the lesion control group had damage to
a wide range of brain areas, we do not further interpret this result.

Interestingly, results revealed that patients with vmPFC successfully exerted the required effort more often for self 
(`r format(round(success.per$mean_success[success.per$Group_vmpfc == "vmPFC" & success.per$Recipient_s2z == "self"], digits=2), nsmall=2)`%
success rate) 
than other 
(`r format(round(success.per$mean_success[success.per$Group_vmpfc == "vmPFC" & success.per$Recipient_s2z == "other"], digits=2), nsmall=2)`%; 
contrast=`r format(round(success.con.all$estimate[success.con.all$contrast == "self vmPFC - other vmPFC"], digits=2), nsmall=2)`,
SE=`r format(round(success.con.all$SE[success.con.all$contrast == "self vmPFC - other vmPFC"], digits=2), nsmall=2)`,
t=`r format(round(success.con.all$t.ratio[success.con.all$contrast == "self vmPFC - other vmPFC"], digits=2), nsmall=2)`,
*p*`r pvalrf(success.con.all$p.value[success.con.all$contrast == "self vmPFC - other vmPFC"])`). 
In contrast, healthy control participants had similar success rates for self 
(`r format(round(success.per$mean_success[success.per$Group_vmpfc == "HC" & success.per$Recipient_s2z == "self"], digits=2), nsmall=2)`%) 
and other 
(`r format(round(success.per$mean_success[success.per$Group_vmpfc == "HC" & success.per$Recipient_s2z == "other"], digits=2), nsmall=2)`%; 
contrast=`r format(round(success.con.all$estimate[success.con.all$contrast == "self HC - other HC"], digits=2), nsmall=2)`,
SE=`r format(round(success.con.all$SE[success.con.all$contrast == "self HC - other HC"], digits=2), nsmall=2)`,
t=`r format(round(success.con.all$t.ratio[success.con.all$contrast == "self HC - other HC"], digits=2), nsmall=2)`,
*p*`r pvalrf(success.con.all$p.value[success.con.all$contrast == "self HC - other HC"])`,
BF<sub>01</sub>=`r format(round(success.bf01.hc.self.other$bf, digits=2), nsmall=2)`; 
LMM group\*recipient interaction
b=`r format(round(r.success$Coefficient[r.success$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. HC)"], digits=3), nsmall=3)`
[`r format(round(r.success$CI_low[r.success$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. HC)"], digits=3), nsmall=3)`,
`r format(round(r.success$CI_high[r.success$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. HC)"], digits=3), nsmall=3)`],
*p*`r pvalrf(r.success$p[r.success$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. HC)"])`). 

#### Figure 5
```{r force-plot, echo = FALSE, warning=FALSE, fig.height=4, fig.width=9.5}

print(force.e.plt)

```
<br>
**Figure 5. Patients with vmPFC lesions exert less force for other relative to self, particularly when a large amount of effort is required.** 
Patients with vmPFC damage exerted less force to obtain reward for the other person than themselves (post-hoc 
contrast=`r format(round(force1.con.all$estimate[force1.con.all$contrast == "self vmPFC - other vmPFC"], digits=2), nsmall=2)`,
SE=`r format(round(force1.con.all$SE[force1.con.all$contrast == "self vmPFC - other vmPFC"], digits=2), nsmall=2)`,
Z=`r format(round(force1.con.all$z.ratio[force1.con.all$contrast == "self vmPFC - other vmPFC"], digits=2), nsmall=2)`,
*p*`r pvalrf(force1.con.all$p.value[force1.con.all$contrast == "self vmPFC - other vmPFC"])`), 
whereas this was not the case for healthy control participants (post-hoc 
contrast=`r format(round(force1.con.all$estimate[force1.con.all$contrast == "self HC - other HC"], digits=2), nsmall=2)`,
SE=`r format(round(force1.con.all$SE[force1.con.all$contrast == "self HC - other HC"], digits=2), nsmall=2)`,
Z=`r format(round(force1.con.all$z.ratio[force1.con.all$contrast == "self HC - other HC"], digits=2), nsmall=2)`,
*p*`r pvalrf(force1.con.all$p.value[force1.con.all$contrast == "self HC - other HC"])`;
LMM group\*recipient interaction 
b=`r format(round(r.force1$Coefficient[r.force1$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`
[`r format(round(r.force1$CI_low[r.force1$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`,
`r format(round(r.force1$CI_high[r.force1$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`],
*p*`r pvalrf(r.force1$p[r.force1$Parameter == "Recipient (Self vs. Other) * Group (vmPFC vs. HC)"])`).
This group difference in energising actions to benefit other, relative to self, 
was particularly large when the level of effort required was greatest (LMM group\*recipient\*effort interaction 
b=`r format(round(r.force1$Coefficient[r.force1$Parameter == "Effort * Recipient (Self vs. Other) * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`
[`r format(round(r.force1$CI_low[r.force1$Parameter == "Effort * Recipient (Self vs. Other) * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`,
`r format(round(r.force1$CI_high[r.force1$Parameter == "Effort * Recipient (Self vs. Other) * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`],
*p*`r pvalrf(r.force1$p[r.force1$Parameter == "Effort * Recipient (Self vs. Other) * Group (vmPFC vs. HC)"])`) 
and also when the reward available was smallest (LMM group\*recipient\*effort\*reward interaction 
b=`r format(round(r.force1$Coefficient[r.force1$Parameter == "Effort * Recipient (Self vs. Other) * Reward * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`
[`r format(round(r.force1$CI_low[r.force1$Parameter == "Effort * Recipient (Self vs. Other) * Reward * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`,
`r format(round(r.force1$CI_high[r.force1$Parameter == "Effort * Recipient (Self vs. Other) * Reward * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`],
*p*`r pvalrf(r.force1$p[r.force1$Parameter == "Effort * Recipient (Self vs. Other) * Reward * Group (vmPFC vs. HC)"])`;
Figure S2 & Table S7).

In summary, multiple behavioural measures and computational parameters 
showed damage to vmPFC specifically reduced willingness to exert effort to help 
another person, compared to controls both with and without lesions. These
differences in prosociality were found in the absence of group
differences in choices, discounting, or force exerted for
oneself. Patients with vmPFC damage also did not show differences in
reward sensitivity but how effort affect choices was altered compared to
healthy controls.

### *Damage to medial vmPFC is associated with decreased willingness to help others whereas lateral vmPFC damage increases prosociality*

[Lesion mapping results]

#### Figure 6
[With brains]
```{r map-roi-allp-plot, echo = FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=9}

map.roi.allp.plt <- plot_grid(choiceV.lab, plot.all.choiceV.Achoice, kV.lab, plot.all.kV.Rk, 
                              ncol = 4, rel_widths = c(0.15,1,0.15,1),
                              labels = c("b", "", "c", ""),
                              label_size = axtitle, axis = "tb", align = "h")

print(map.roi.allp.plt)

map.roi.allp.plt.raw <- plot_grid(choiceV.lab, plot.all.choiceV.Achoice.raw, kV.lab, plot.all.kV.Rk.raw, 
                              ncol = 4, rel_widths = c(0.15,1,0.15,1),
                              labels = c("b", "", "c", ""),
                              label_size = axtitle, axis = "tb", align = "h")

print(map.roi.allp.plt.raw)

```


#### Figure 7
[With brains]
```{r map-roi-vmpfc-plot, echo = FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=9}

map.roi.vmpfc.plt <- plot_grid(choiceV.lab, plot.vmpfc.choiceV.Achoice, kV.lab, plot.vmpfc.kV.Rk, 
                               ncol = 4, rel_widths = c(0.15,1,0.15,1),
                               labels = c("b", "", "c", ""),
                               label_size = axtitle, axis = "tb", align = "h")

print(map.roi.vmpfc.plt)

map.roi.allp.plt.raw <- plot_grid(choiceV.lab, plot.vmpfc.choiceV.Achoice.raw, kV.lab, plot.vmpfc.kV.Rk.raw, 
                              ncol = 4, rel_widths = c(0.15,1,0.15,1),
                              labels = c("b", "", "c", ""),
                              label_size = axtitle, axis = "tb", align = "h")

print(map.roi.allp.plt.raw)

```


#### Figure 8
[Just brains for reward effects]

# Supplement

```{r choice-mod-plot, eval=FALSE, echo = FALSE, warning=FALSE, fig.height=4, fig.width=10}

choice.mod.plt <- plot_grid(choice.eg.plt, choice.rg.plt, ncol = 2, rel_widths = c(0.7,1), labels = c("a","b"), label_size = axtitle, axis = "tb", align = "h")

print(choice.mod.plt)

```

#### Figure S1

```{r b-plot, echo = FALSE, warning=FALSE, fig.height=5, fig.width=5}

print(b.plt)

```
<br>
**Figure S1. Choice consistency is higher for self than other but no significant effect of vmPFC damage.** Analysis of choice stochasticity `r "<i>\u03B2</i>"` parameters revealed choices in all three groups more consistently followed the relative subjective value between options. However, there were no significant differences between groups in choice consistency overall and importantly no significant interactions between group and recipient in predicting `r "<i>\u03B2</i>"` parameters (Table S7 & Table S8).

#### Figure S2

```{r force-rew-plot, echo = FALSE, warning=FALSE, fig.height=8, fig.width=8}

print(force.er.plt)

```
<br>
**Figure S2. vmPFC damage decreases the force exerted to gain rewards for another person, compared to oneself, as the effort required increases, particularly for the smallest rewards.** In addition to the group\*recipient and group\*recipient\*effort interactions shown in Figure 5, the linear mixed-effects model of force exerted showed a significant 4-way group\*recipient\*effort\*reward interaction 
(b=`r format(round(r.force1$Coefficient[r.force1$Parameter == "Effort * Recipient (Self vs. Other) * Reward * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`
[`r format(round(r.force1$CI_low[r.force1$Parameter == "Effort * Recipient (Self vs. Other) * Reward * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`,
`r format(round(r.force1$CI_high[r.force1$Parameter == "Effort * Recipient (Self vs. Other) * Reward * Group (vmPFC vs. HC)"], digits=2), nsmall=2)`],
*p*`r pvalrf(r.force1$p[r.force1$Parameter == "Effort * Recipient (Self vs. Other) * Reward * Group (vmPFC vs. HC)"])`; Table S9 & S10). This sensitivity to the reward available and effort required, combined with high overall success rates, suggests vmPFC patients' reduced willingness to exert force for prosocial rewards was not due to an inability to meet the required force or attend to the information in the trial.

#### Figure S3

```{r lesion-size-plot, echo = FALSE, warning=FALSE, message=FALSE, fig.height=10, fig.width=12}

lesion.size.plt <- plot_grid(plot.size.Achoice, plot.size.Rk, plot.size.Echoice, plot.size.Rchoice, ncol = 2, labels = "auto", label_size = axtitle, axis = "tb", align = "h")

lesion.size.plt <- plot_grid(lesion.size.plt, lesion.size.leg, ncol=2, rel_widths = c(1,0.25), rel_heights = c(1,0.15))

print(lesion.size.plt)

```
**Figure S3. No significant correlations between total lesion size and the behavioural predictors for VLSM.** As a control analysis to support the voxel-based lesion symptom mapping (VLSM), we correlated total lesion volume with each of the four behavioural predictors, calculated as the (ranked) participant-level random effects from the generalised linear mixed-effects models of choices and `r "<i>\u039A</i>"` parameters (effect of recipient on choices, effect of reward on choices, effect of effort on choices, effect of recipient on `r "<i>\u039A</i>"` parameters). The lack of significant correlations in all cases suggests that overall lesion size did not confound the VLSM analysis and results are specific to damage in each of the identified subregions.

#### Figure S4

```{r lesion-SO-allp-plot, echo = FALSE, warning=FALSE, message=FALSE, fig.height=12, fig.width=9}

map.SO.allp.plt <- plot_grid(choice.lab, plot.all.choiceV.Ochoice, choice.lab, plot.all.choiceV.Schoice,
                             NA, NA, NA, NA,
                             k.lab, plot.all.kV.Ok, k.lab, plot.all.kV.Sk,
                             ncol = 4, rel_widths = c(0.15,1,0.15,1),
                             rel_heights = c(1,0.1,1),
                             labels = c("a", "", "b", "", "c", "", "d", ""),
                             label_size = axtitle, axis = "tb", align = "h")

print(map.SO.allp.plt)

```
**Figure S4. Damage to medial vmPFC regions decreases willingness to exert effort for others and increases willingness to obtain self-benefitting rewards.** To further interpret the voxel-based lesion symptom mapping (VLSM) finding of decreased prosociality with damage to portions of vmPFC on the medial wall (area 14m and 32), we plotted each recipient separately to examine how damage affects **(a)** choices for other **(b)** choices for self **(c)** discounting `r paste(klabel)`s for other and **(d)** discounting `r "<i>\u039A</i>"` parameters for self. We categorised participants by whether they had damage or not in the areas identified in the VLSM analysis for each effect (choices and `r "<i>\u039A</i>"`; see Figure 6A). These plots suggest that decreased prosociality shown by the recipient effects (other vs. self) in the VLSM are driven by both lower willingness to help the other person and higher willingness to work for oneself in patients with damage to these regions.

#### Figure S5

```{r lesion-SO-vmpfc-plot, echo = FALSE, warning=FALSE, message=FALSE, fig.height=5, fig.width=9}

map.SO.k.plt <- plot_grid(k.lab, plot.vmpfc.kV.Ok, k.lab, plot.vmpfc.kV.Sk,
                          ncol = 4, rel_widths = c(0.15,1,0.15,1),
                          labels = c("a", "", "b", ""),
                          label_size = axtitle, axis = "tb", align = "h")

print(map.SO.k.plt)

```
**Figure S5. Damage to lateral vmPFC increases willingness to help others and decreases willingness to exert effort for oneself.** Our voxel-based lesion symptom mapping (VLSM) analysis identified a lateral portion of vmPFC in area 13a/b where damage was paradoxically associated with increased prosociality. To further interpret this finding, we extracted the extent of damage for each participant in the region identified in the VLSM analysis of the recipient effect (other vs. self) on `r paste(klabel)`. The corresponding effect on choices was associated with a smaller, overlapping region of area 13a/b (see Figure 7). Plotting damage in this region against **(a)** discounting `r paste(klabel)` for other and **(b)** discounting `r paste(klabel)` for self separately shows the increase in relative prosociality is driven by both lower discounting (higher willingness to work) for other and higher discounting (lower willingness to work) to some extent for self.

#### Table S0 (new S1)

```{r demographics-f, warning=FALSE, message=FALSE, echo=FALSE}

r.m <- d.means

r.m$w_pval_hc_vmPFC[!is.na(r.m$w_pval_hc_vmPFC)] <- pvalr(r.m$w_pval_hc_vmPFC[!is.na(r.m$w_pval_hc_vmPFC)])
r.m$w_pval_hc_lc[!is.na(r.m$w_pval_hc_lc)] <- pvalr(r.m$w_pval_hc_lc[!is.na(r.m$w_pval_hc_lc)])
r.m$w_pval_lc_vmPFC[!is.na(r.m$w_pval_lc_vmPFC)] <- pvalr(r.m$w_pval_lc_vmPFC[!is.na(r.m$w_pval_lc_vmPFC)])

colnames(r.m) <- str_remove(colnames(r.m), "d.means.")
colnames(r.m) <- str_replace(colnames(r.m), pattern = "d.sds.", replacement = "SD ")
colnames(r.m) <- str_remove(colnames(r.m), "w_pval_")
colnames(r.m) <- str_replace(colnames(r.m), pattern = "_", replacement = " vs. ")

r.m <- r.m %>% 
  mutate(measure = str_remove(r.m$measure, pattern = "_total"))

r.m <- r.m %>% 
  mutate(measure = str_remove(r.m$measure, pattern = "_tot")) %>% 
  mutate(measure = str_replace(r.m$measure, pattern = "_", replacement = " ")) 

kable(r.m,
      digits = 2,
      align = c('l',rep('c',(ncol(r.m)-1))),
      caption = paste0("Summary of demographic variables for each group")) %>% kable_styling()

```

#### Table S1

```{r credits-models-f, warning=FALSE, message=FALSE, echo=FALSE}

r.credits$p[!is.na(r.credits$p)] <- pvalr(r.credits$p[!is.na(r.credits$p)])

kable(r.credits,
      digits = 2,
      align = c('l',rep('c',(ncol(r.credits)-1))),
      caption = "Generalised linear mixed-effects model predicting credits") %>% kable_styling()

if (savecsvs == 1) {write.table(r.credits, file = "output/Table_model_credits.csv", sep = ",", row.names = F)}

```

#### Table S

```{r credit-posthoc-f, echo = FALSE, warning=FALSE}

credits.con.all$p.value[!is.na(credits.con.all$p.value)] <- pvalr(credits.con.all$p.value[!is.na(credits.con.all$p.value)])

kable(credits.con.all,
      digits = 2,
      align = c('l','l',rep('c',(ncol(credits.con.all)-2))),
      caption = paste0("Post-hoc tests on model of credits")) %>% kable_styling()
```

#### Table S2

```{r choice-models-f, warning=FALSE, message=FALSE, echo=FALSE}

r.choice$p[!is.na(r.choice$p)] <- pvalr(r.choice$p[!is.na(r.choice$p)])
kable(r.choice,
      digits = 2,
      align = c('l',rep('c',(ncol(r.choice)-1))),
      caption = "Generalised linear mixed-effects model predicting choices") %>% kable_styling()

if (savecsvs == 1) {write.table(r.choice, file = "output/Table_model_choice.csv", sep = ",", row.names = F)}

```

#### Table S

```{r choice-posthoc-f, echo = FALSE, warning=FALSE}

choice.con.all$p.value[!is.na(choice.con.all$p.value)] <- pvalr(choice.con.all$p.value[!is.na(choice.con.all$p.value)])

kable(choice.con.all,
      digits = 2,
      align = c('l','l',rep('c',(ncol(choice.con.all)-2))),
      caption = paste0("Post-hoc tests on model of choices")) %>% kable_styling()
```

#### Table S3

```{r k-model-f, echo = FALSE, warning=FALSE}

r.k$p[!is.na(r.k$p)] <- pvalr(r.k$p[!is.na(r.k$p)])

kable(r.k,
      digits = 2,
      align = c('l',rep('c',(ncol(r.k)-1))),
      caption = paste0("Generalised linear mixed-effects model predicting ", klabel)) %>% kable_styling()
```

#### Table S

```{r k-posthoc-f, echo = FALSE, warning=FALSE}

k.con.all$p.value[!is.na(k.con.all$p.value)] <- pvalr(k.con.all$p.value[!is.na(k.con.all$p.value)])

kable(k.con.all,
      digits = 2,
      align = c('l','l',rep('c',(ncol(k.con.all)-2))),
      caption = paste0("Post-hoc tests on model of ", klabel)) %>% kable_styling()
```

#### Table S4

```{r b-model-f, echo = FALSE, warning=FALSE}

r.beta$p[!is.na(r.beta$p)] <- pvalr(r.beta$p[!is.na(r.beta$p)])

kable(r.beta,
      digits = 2,
      align = c('l',rep('c',(ncol(r.beta)-1))),
      caption = paste0("Generalised linear mixed-effects model predicting ", blabel)) %>% kable_styling()
```

#### Table S

```{r b-posthoc-f, echo = FALSE, warning=FALSE}

beta.con.all$p.value[!is.na(beta.con.all$p.value)] <- pvalr(beta.con.all$p.value[!is.na(beta.con.all$p.value)])

kable(beta.con.all,
      digits = 2,
      align = c('l','l',rep('c',(ncol(beta.con.all)-2))),
      caption = paste0("Post-hoc tests on model of ", blabel)) %>% kable_styling()
```

#### Table S5

```{r force-model1-f, warning=FALSE, message=FALSE, echo=FALSE}

r.force1$p[!is.na(r.force1$p)] <- pvalr(r.force1$p[!is.na(r.force1$p)])

kable(r.force1,
      digits = 2,
      align = c('l',rep('c',(ncol(r.force1)-1))),
      caption = "Linear mixed-effects model predicting force") %>% kable_styling()

if (savecsvs == 1) {write.table(r.force1, file = "output/Table_model1_force.csv", sep = ",", row.names = F)}

```

#### Table S

```{r force-posthoc-f, echo = FALSE, warning=FALSE}

force1.con.all$p.value[!is.na(force1.con.all$p.value)] <- pvalr(force1.con.all$p.value[!is.na(force1.con.all$p.value)])

kable(force1.con.all,
      digits = 2,
      align = c('l','l',rep('c',(ncol(force1.con.all)-2))),
      caption = "Post-hoc tests on model of force") %>% kable_styling()

```

#### Table S6

```{r success-model-f, echo = FALSE, warning=FALSE}

r.success$p[!is.na(r.success$p)] <- pvalr(r.success$p[!is.na(r.success$p)])

kable(r.success,
      digits = 2,
      align = c('l',rep('c',(ncol(r.success)-1))),
      caption = paste0("Linear mixed-effects model predicting success")) %>% kable_styling()
```

#### Table S

```{r success-posthoc-f, echo = FALSE, warning=FALSE}

success.con.all$p.value[!is.na(success.con.all$p.value)] <- pvalr(success.con.all$p.value[!is.na(success.con.all$p.value)])

kable(success.con.all,
      digits = 2,
      align = c('l','l',rep('c',(ncol(success.con.all)-2))),
      caption = paste0("Post-hoc tests on model of success")) %>% kable_styling()
```
